; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\timer.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\timer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\ATK-ESP8266 -I..\CORE -I..\FATFS\src -I..\FATFS\exfuns -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\LED -I..\HARDWARE\SDIO -I..\HARDWARE\SPI -I..\HARDWARE\TIMER -I..\HARDWARE\TOUCH -I..\HARDWARE\USART3 -I..\HARDWARE\W25QXX -I..\MALLOC -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\TEXT -I..\USER -I..\USMART -I..\PICTURE -I..\HARDWARE\OV7725 -I..\HARDWARE\EXTI -I..\HARDWARE\BEEP -I..\HARDWARE\DHT11 -I.\RTE\_Target_1 -ID:\Users\86132\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\timer.crf ..\HARDWARE\TIMER\timer.c]
                          THUMB

                          AREA ||i.TIM1_PWM_Init||, CODE, READONLY, ALIGN=2

                  TIM1_PWM_Init PROC
;;;223    //psc：时钟预分频数
;;;224    void TIM1_PWM_Init(u16 arr,u16 psc)
000000  b530              PUSH     {r4,r5,lr}
;;;225    {		 					 
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;226    	
;;;227     	
;;;228    	GPIO_InitTypeDef GPIO_InitStructure;
;;;229    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;230    	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;231    	
;;;232    
;;;233    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); //使能TIMx外设
000008  2101              MOVS     r1,#1
00000a  02c8              LSLS     r0,r1,#11
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;234     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);  //使能GPIOA外设时钟使能
000010  2101              MOVS     r1,#1
000012  2008              MOVS     r0,#8
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;235    	
;;;236     
;;;237      //设置该引脚为复用输出功能,输出TIM1 CH1的PWM脉冲波形
;;;238    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8; //TIM_CH1
000018  f44f7080          MOV      r0,#0x100
00001c  f8ad0020          STRH     r0,[sp,#0x20]
;;;239    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用功能输出
000020  2018              MOVS     r0,#0x18
000022  f88d0023          STRB     r0,[sp,#0x23]
;;;240    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000026  2003              MOVS     r0,#3
000028  f88d0022          STRB     r0,[sp,#0x22]
;;;241    	GPIO_Init(GPIOA, &GPIO_InitStructure); //初始化GPIO
00002c  a908              ADD      r1,sp,#0x20
00002e  4819              LDR      r0,|L1.148|
000030  f7fffffe          BL       GPIO_Init
;;;242     
;;;243    	TIM_TimeBaseStructure.TIM_Period = arr; //设置自动重装载周期值
000034  f8ad5018          STRH     r5,[sp,#0x18]
;;;244    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置预分频值 不分频
000038  f8ad4014          STRH     r4,[sp,#0x14]
;;;245    	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
00003c  2000              MOVS     r0,#0
00003e  f8ad001a          STRH     r0,[sp,#0x1a]
;;;246    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
000042  f8ad0016          STRH     r0,[sp,#0x16]
;;;247    	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx
000046  a905              ADD      r1,sp,#0x14
000048  4813              LDR      r0,|L1.152|
00004a  f7fffffe          BL       TIM_TimeBaseInit
;;;248    	
;;;249    	 
;;;250    	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //CH1 PWM2模式	
00004e  2070              MOVS     r0,#0x70
000050  f8ad0004          STRH     r0,[sp,#4]
;;;251    	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能
000054  2001              MOVS     r0,#1
000056  f8ad0006          STRH     r0,[sp,#6]
;;;252    	TIM_OCInitStructure.TIM_Pulse = 0; //设置待装入捕获比较寄存器的脉冲值
00005a  2000              MOVS     r0,#0
00005c  f8ad000a          STRH     r0,[sp,#0xa]
;;;253    	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low; //OC1 低电平有效 
000060  2002              MOVS     r0,#2
000062  f8ad000c          STRH     r0,[sp,#0xc]
;;;254    	TIM_OC1Init(TIM1, &TIM_OCInitStructure);  //根据指定的参数初始化外设TIMx
000066  a901              ADD      r1,sp,#4
000068  480b              LDR      r0,|L1.152|
00006a  f7fffffe          BL       TIM_OC1Init
;;;255    
;;;256    	TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);  //CH1 预装载使能
00006e  2108              MOVS     r1,#8
000070  4809              LDR      r0,|L1.152|
000072  f7fffffe          BL       TIM_OC1PreloadConfig
;;;257    	
;;;258    	TIM_ARRPreloadConfig(TIM1, ENABLE); //使能TIMx在ARR上的预装载寄存器
000076  2101              MOVS     r1,#1
000078  4807              LDR      r0,|L1.152|
00007a  f7fffffe          BL       TIM_ARRPreloadConfig
;;;259    	
;;;260    	TIM_CtrlPWMOutputs(TIM1,ENABLE);	//MOE 主输出使能,高级定时器必须开启这个 
00007e  2101              MOVS     r1,#1
000080  4805              LDR      r0,|L1.152|
000082  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;261    	
;;;262    	TIM_Cmd(TIM1, ENABLE);  //使能TIMx
000086  2101              MOVS     r1,#1
000088  4803              LDR      r0,|L1.152|
00008a  f7fffffe          BL       TIM_Cmd
;;;263    	   										  
;;;264    } 
00008e  b009              ADD      sp,sp,#0x24
000090  bd30              POP      {r4,r5,pc}
;;;265    
                          ENDP

000092  0000              DCW      0x0000
                  |L1.148|
                          DCD      0x40010800
                  |L1.152|
                          DCD      0x40012c00

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;78     
;;;79     void TIM3_IRQHandler(void)   //TIM3中断
000000  b510              PUSH     {r4,lr}
;;;80     {
;;;81     	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 
000002  2101              MOVS     r1,#1
000004  4808              LDR      r0,|L2.40|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b158              CBZ      r0,|L2.36|
;;;82     		{
;;;83     		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  //清除TIMx的中断待处理位:TIM 中断源 
00000c  2101              MOVS     r1,#1
00000e  4806              LDR      r0,|L2.40|
000010  f7fffffe          BL       TIM_ClearITPendingBit
;;;84     		LED1=!LED1;
000014  4805              LDR      r0,|L2.44|
000016  6800              LDR      r0,[r0,#0]
000018  b908              CBNZ     r0,|L2.30|
00001a  2001              MOVS     r0,#1
00001c  e000              B        |L2.32|
                  |L2.30|
00001e  2000              MOVS     r0,#0
                  |L2.32|
000020  4902              LDR      r1,|L2.44|
000022  6008              STR      r0,[r1,#0]
                  |L2.36|
;;;85     		}
;;;86     }
000024  bd10              POP      {r4,pc}
;;;87     
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      0x40000400
                  |L2.44|
                          DCD      0x42230194

                          AREA ||i.TIM3_Int_Init||, CODE, READONLY, ALIGN=2

                  TIM3_Int_Init PROC
;;;54     }
;;;55     void TIM3_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;56     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;57       TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;58     	NVIC_InitTypeDef NVIC_InitStructure;
;;;59     
;;;60     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;61     
;;;62     	TIM_TimeBaseStructure.TIM_Period = arr; //自动重装载周期值	
00000e  f8ad5008          STRH     r5,[sp,#8]
;;;63     	TIM_TimeBaseStructure.TIM_Prescaler =psc; //预分频值  
000012  f8ad4004          STRH     r4,[sp,#4]
;;;64     	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000016  2000              MOVS     r0,#0
000018  f8ad000a          STRH     r0,[sp,#0xa]
;;;65     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
00001c  f8ad0006          STRH     r0,[sp,#6]
;;;66     	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据指定的参数初始化TIMx
000020  a901              ADD      r1,sp,#4
000022  480e              LDR      r0,|L3.92|
000024  f7fffffe          BL       TIM_TimeBaseInit
;;;67      
;;;68     	TIM_ITConfig(  TIM3,TIM_IT_Update  |  TIM_IT_Trigger,  ENABLE  );//使能更新触发TIM中断
000028  2201              MOVS     r2,#1
00002a  2141              MOVS     r1,#0x41
00002c  480b              LDR      r0,|L3.92|
00002e  f7fffffe          BL       TIM_ITConfig
;;;69     
;;;70     	//中断分组设置
;;;71     	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  //TIM3中断
000032  201d              MOVS     r0,#0x1d
000034  f88d0000          STRB     r0,[sp,#0]
;;;72     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级
000038  2000              MOVS     r0,#0
00003a  f88d0001          STRB     r0,[sp,#1]
;;;73     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级
00003e  2003              MOVS     r0,#3
000040  f88d0002          STRB     r0,[sp,#2]
;;;74     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
000044  2001              MOVS     r0,#1
000046  f88d0003          STRB     r0,[sp,#3]
;;;75     	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       NVIC_Init
;;;76     	TIM_Cmd(TIM3, ENABLE);  //使能TIMx外设
000050  2101              MOVS     r1,#1
000052  4802              LDR      r0,|L3.92|
000054  f7fffffe          BL       TIM_Cmd
;;;77     }
000058  bd7f              POP      {r0-r6,pc}
;;;78     
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      0x40000400

                          AREA ||i.TIM3_PWM_Init||, CODE, READONLY, ALIGN=2

                  TIM3_PWM_Init PROC
;;;94     
;;;95     void TIM3_PWM_Init(u16 arr,u16 psc)
000000  b530              PUSH     {r4,r5,lr}
;;;96     {  
000002  b089              SUB      sp,sp,#0x24
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;97     	GPIO_InitTypeDef GPIO_InitStructure;
;;;98     	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;99     	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;100    	
;;;101    
;;;102    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;103     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  | RCC_APB2Periph_AFIO, ENABLE);  //使能GPIO外设和AFIO复用功能模块时钟使能
000010  2101              MOVS     r1,#1
000012  2009              MOVS     r0,#9
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;104    	
;;;105    	GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3部分重映射  TIM3_CH2->PB5                                                                       	 //用于TIM3的CH2输出的PWM通过该LED显示
000018  2101              MOVS     r1,#1
00001a  481d              LDR      r0,|L4.144|
00001c  f7fffffe          BL       GPIO_PinRemapConfig
;;;106     
;;;107       //设置该引脚为复用输出功能,输出TIM3 CH2的PWM脉冲波形
;;;108    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5; //TIM_CH2
000020  2020              MOVS     r0,#0x20
000022  f8ad0020          STRH     r0,[sp,#0x20]
;;;109    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用推挽输出
000026  2018              MOVS     r0,#0x18
000028  f88d0023          STRB     r0,[sp,#0x23]
;;;110    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002c  2003              MOVS     r0,#3
00002e  f88d0022          STRB     r0,[sp,#0x22]
;;;111    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000032  a908              ADD      r1,sp,#0x20
000034  4817              LDR      r0,|L4.148|
000036  f7fffffe          BL       GPIO_Init
;;;112    	//GPIO_WriteBit(GPIOA, GPIO_Pin_7,Bit_SET); // PA7上拉	
;;;113    
;;;114    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 80K
00003a  f8ad5018          STRH     r5,[sp,#0x18]
;;;115    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  不分频
00003e  f8ad4014          STRH     r4,[sp,#0x14]
;;;116    	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000042  2000              MOVS     r0,#0
000044  f8ad001a          STRH     r0,[sp,#0x1a]
;;;117    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
000048  f8ad0016          STRH     r0,[sp,#0x16]
;;;118    	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
00004c  a905              ADD      r1,sp,#0x14
00004e  4812              LDR      r0,|L4.152|
000050  f7fffffe          BL       TIM_TimeBaseInit
;;;119    	
;;;120    	 
;;;121    	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择定时器模式:TIM脉冲宽度调制模式2
000054  2070              MOVS     r0,#0x70
000056  f8ad0004          STRH     r0,[sp,#4]
;;;122    	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能
00005a  2001              MOVS     r0,#1
00005c  f8ad0006          STRH     r0,[sp,#6]
;;;123    	TIM_OCInitStructure.TIM_Pulse = 0; //设置待装入捕获比较寄存器的脉冲值
000060  2000              MOVS     r0,#0
000062  f8ad000a          STRH     r0,[sp,#0xa]
;;;124    	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性:TIM输出比较极性高
000066  f8ad000c          STRH     r0,[sp,#0xc]
;;;125    	TIM_OC2Init(TIM3, &TIM_OCInitStructure);  //根据TIM_OCInitStruct中指定的参数初始化外设TIMx
00006a  a901              ADD      r1,sp,#4
00006c  480a              LDR      r0,|L4.152|
00006e  f7fffffe          BL       TIM_OC2Init
;;;126    	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);  //使能TIMx在CCR2上的预装载寄存器
000072  2108              MOVS     r1,#8
000074  4808              LDR      r0,|L4.152|
000076  f7fffffe          BL       TIM_OC2PreloadConfig
;;;127    	
;;;128    	TIM_ARRPreloadConfig(TIM3, ENABLE); //使能TIMx在ARR上的预装载寄存器
00007a  2101              MOVS     r1,#1
00007c  4806              LDR      r0,|L4.152|
00007e  f7fffffe          BL       TIM_ARRPreloadConfig
;;;129    	
;;;130     
;;;131    	TIM_Cmd(TIM3, ENABLE);  //使能TIMx外设
000082  2101              MOVS     r1,#1
000084  4804              LDR      r0,|L4.152|
000086  f7fffffe          BL       TIM_Cmd
;;;132     
;;;133    
;;;134    }
00008a  b009              ADD      sp,sp,#0x24
00008c  bd30              POP      {r4,r5,pc}
;;;135    
                          ENDP

00008e  0000              DCW      0x0000
                  |L4.144|
                          DCD      0x001a0800
                  |L4.148|
                          DCD      0x40010c00
                  |L4.152|
                          DCD      0x40000400

                          AREA ||i.TIM5_Cap_Init||, CODE, READONLY, ALIGN=2

                  TIM5_Cap_Init PROC
;;;139    
;;;140    void TIM5_Cap_Init(u16 arr,u16 psc)
000000  b530              PUSH     {r4,r5,lr}
;;;141    {	 
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;142    	GPIO_InitTypeDef GPIO_InitStructure;
;;;143    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;144       	NVIC_InitTypeDef NVIC_InitStructure;
;;;145    
;;;146    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2008              MOVS     r0,#8
00000c  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;147     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);  //使能GPIO外设和AFIO复用功能模块时钟使能
000010  2101              MOVS     r1,#1
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;148    	
;;;149    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_0;  //PA0 清除之前设置  
000018  2001              MOVS     r0,#1
00001a  f8ad0010          STRH     r0,[sp,#0x10]
;;;150    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD; //PA0 输入  
00001e  2028              MOVS     r0,#0x28
000020  f88d0013          STRB     r0,[sp,#0x13]
;;;151    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000024  a904              ADD      r1,sp,#0x10
000026  481d              LDR      r0,|L5.156|
000028  f7fffffe          BL       GPIO_Init
;;;152    	GPIO_ResetBits(GPIOA,GPIO_Pin_0);						 //PA0 下拉
00002c  2101              MOVS     r1,#1
00002e  481b              LDR      r0,|L5.156|
000030  f7fffffe          BL       GPIO_ResetBits
;;;153    		 
;;;154    	TIM_TimeBaseStructure.TIM_Period = arr; //设定计数器自动重装值 最大10ms溢出  
000034  f8ad5008          STRH     r5,[sp,#8]
;;;155    	TIM_TimeBaseStructure.TIM_Prescaler =psc; 	//预分频器,1M的计数频率,1us加1.	   
000038  f8ad4004          STRH     r4,[sp,#4]
;;;156    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
00003c  2000              MOVS     r0,#0
00003e  f8ad000a          STRH     r0,[sp,#0xa]
;;;157    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
000042  f8ad0006          STRH     r0,[sp,#6]
;;;158    
;;;159    	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000046  a901              ADD      r1,sp,#4
000048  4815              LDR      r0,|L5.160|
00004a  f7fffffe          BL       TIM_TimeBaseInit
;;;160      
;;;161    	TIM5_ICInitStructure.TIM_Channel = TIM_Channel_1; //CC1S=01 	选择输入端 IC1映射到TI1上
00004e  2000              MOVS     r0,#0
000050  4914              LDR      r1,|L5.164|
000052  8008              STRH     r0,[r1,#0]
;;;162      	TIM5_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;	//上升沿捕获
000054  8048              STRH     r0,[r1,#2]
;;;163      	TIM5_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
000056  2001              MOVS     r0,#1
000058  8088              STRH     r0,[r1,#4]
;;;164      	TIM5_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;	 //配置输入分频,不分频 
00005a  2000              MOVS     r0,#0
00005c  80c8              STRH     r0,[r1,#6]
;;;165      	TIM5_ICInitStructure.TIM_ICFilter = 0x00;//IC1F=0000 配置输入滤波器 不滤波
00005e  8108              STRH     r0,[r1,#8]
;;;166    
;;;167      	TIM_ICInit(TIM5, &TIM5_ICInitStructure);
000060  480f              LDR      r0,|L5.160|
000062  f7fffffe          BL       TIM_ICInit
;;;168    		
;;;169       	TIM_Cmd(TIM5,ENABLE ); 	//使能定时器5
000066  2101              MOVS     r1,#1
000068  480d              LDR      r0,|L5.160|
00006a  f7fffffe          BL       TIM_Cmd
;;;170       	TIM_ITConfig( TIM5,TIM_IT_Update|TIM_IT_CC1,ENABLE);//允许更新中断 ,允许CC1IE捕获中断	
00006e  2201              MOVS     r2,#1
000070  2103              MOVS     r1,#3
000072  480b              LDR      r0,|L5.160|
000074  f7fffffe          BL       TIM_ITConfig
;;;171    
;;;172    
;;;173    	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;  //TIM3中断
000078  2032              MOVS     r0,#0x32
00007a  f88d0000          STRB     r0,[sp,#0]
;;;174    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;  //先占优先级0级
00007e  2002              MOVS     r0,#2
000080  f88d0001          STRB     r0,[sp,#1]
;;;175    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;  //从优先级3级
000084  2000              MOVS     r0,#0
000086  f88d0002          STRB     r0,[sp,#2]
;;;176    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
00008a  2001              MOVS     r0,#1
00008c  f88d0003          STRB     r0,[sp,#3]
;;;177    	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 
000090  4668              MOV      r0,sp
000092  f7fffffe          BL       NVIC_Init
;;;178    }
000096  b005              ADD      sp,sp,#0x14
000098  bd30              POP      {r4,r5,pc}
;;;179    
                          ENDP

00009a  0000              DCW      0x0000
                  |L5.156|
                          DCD      0x40010800
                  |L5.160|
                          DCD      0x40000c00
                  |L5.164|
                          DCD      TIM5_ICInitStructure

                          AREA ||i.TIM5_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM5_IRQHandler PROC
;;;183    //定时器5中断服务程序	 
;;;184    void TIM5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;185    { 
;;;186     	if((TIM5CH1_CAPTURE_STA&0X80)==0)//还未成功捕获	
000002  482c              LDR      r0,|L6.180|
000004  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
000006  f0000080          AND      r0,r0,#0x80
00000a  2800              CMP      r0,#0
00000c  d14c              BNE      |L6.168|
;;;187    	{	  
;;;188    		if (TIM_GetITStatus(TIM5, TIM_IT_Update) != RESET)
00000e  2101              MOVS     r1,#1
000010  4829              LDR      r0,|L6.184|
000012  f7fffffe          BL       TIM_GetITStatus
000016  b1d0              CBZ      r0,|L6.78|
;;;189    		 
;;;190    		{	    
;;;191    			if(TIM5CH1_CAPTURE_STA&0X40)//已经捕获到高电平了
000018  4826              LDR      r0,|L6.180|
00001a  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
00001c  f0000040          AND      r0,r0,#0x40
000020  b1a8              CBZ      r0,|L6.78|
;;;192    			{
;;;193    				if((TIM5CH1_CAPTURE_STA&0X3F)==0X3F)//高电平太长了
000022  4824              LDR      r0,|L6.180|
000024  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
000026  f000003f          AND      r0,r0,#0x3f
00002a  283f              CMP      r0,#0x3f
00002c  d10a              BNE      |L6.68|
;;;194    				{
;;;195    					TIM5CH1_CAPTURE_STA|=0X80;//标记成功捕获了一次
00002e  4821              LDR      r0,|L6.180|
000030  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
000032  f0400080          ORR      r0,r0,#0x80
000036  491f              LDR      r1,|L6.180|
000038  7008              STRB     r0,[r1,#0]
;;;196    					TIM5CH1_CAPTURE_VAL=0XFFFF;
00003a  f64f70ff          MOV      r0,#0xffff
00003e  491f              LDR      r1,|L6.188|
000040  8008              STRH     r0,[r1,#0]
000042  e004              B        |L6.78|
                  |L6.68|
;;;197    				}else TIM5CH1_CAPTURE_STA++;
000044  481b              LDR      r0,|L6.180|
000046  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
000048  1c40              ADDS     r0,r0,#1
00004a  491a              LDR      r1,|L6.180|
00004c  7008              STRB     r0,[r1,#0]
                  |L6.78|
;;;198    			}	 
;;;199    		}
;;;200    	if (TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET)//捕获1发生捕获事件
00004e  2102              MOVS     r1,#2
000050  4819              LDR      r0,|L6.184|
000052  f7fffffe          BL       TIM_GetITStatus
000056  b338              CBZ      r0,|L6.168|
;;;201    		{	
;;;202    			if(TIM5CH1_CAPTURE_STA&0X40)		//捕获到一个下降沿 		
000058  4816              LDR      r0,|L6.180|
00005a  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
00005c  f0000040          AND      r0,r0,#0x40
000060  b178              CBZ      r0,|L6.130|
;;;203    			{	  			
;;;204    				TIM5CH1_CAPTURE_STA|=0X80;		//标记成功捕获到一次上升沿
000062  4814              LDR      r0,|L6.180|
000064  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
000066  f0400080          ORR      r0,r0,#0x80
00006a  4912              LDR      r1,|L6.180|
00006c  7008              STRB     r0,[r1,#0]
;;;205    				TIM5CH1_CAPTURE_VAL=TIM_GetCapture1(TIM5);
00006e  4812              LDR      r0,|L6.184|
000070  f7fffffe          BL       TIM_GetCapture1
000074  4911              LDR      r1,|L6.188|
000076  8008              STRH     r0,[r1,#0]
;;;206    		   		TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Rising); //CC1P=0 设置为上升沿捕获
000078  2100              MOVS     r1,#0
00007a  480f              LDR      r0,|L6.184|
00007c  f7fffffe          BL       TIM_OC1PolarityConfig
000080  e012              B        |L6.168|
                  |L6.130|
;;;207    			}else  								//还未开始,第一次捕获上升沿
;;;208    			{
;;;209    				TIM5CH1_CAPTURE_STA=0;			//清空
000082  2000              MOVS     r0,#0
000084  490b              LDR      r1,|L6.180|
000086  7008              STRB     r0,[r1,#0]
;;;210    				TIM5CH1_CAPTURE_VAL=0;
000088  490c              LDR      r1,|L6.188|
00008a  8008              STRH     r0,[r1,#0]
;;;211    	 			TIM_SetCounter(TIM5,0);
00008c  2100              MOVS     r1,#0
00008e  480a              LDR      r0,|L6.184|
000090  f7fffffe          BL       TIM_SetCounter
;;;212    				TIM5CH1_CAPTURE_STA|=0X40;		//标记捕获到了上升沿
000094  4807              LDR      r0,|L6.180|
000096  7800              LDRB     r0,[r0,#0]  ; TIM5CH1_CAPTURE_STA
000098  f0400040          ORR      r0,r0,#0x40
00009c  4905              LDR      r1,|L6.180|
00009e  7008              STRB     r0,[r1,#0]
;;;213    		   	TIM_OC1PolarityConfig(TIM5,TIM_ICPolarity_Falling);		//CC1P=1 设置为下降沿捕获
0000a0  2102              MOVS     r1,#2
0000a2  4805              LDR      r0,|L6.184|
0000a4  f7fffffe          BL       TIM_OC1PolarityConfig
                  |L6.168|
;;;214    			}		    
;;;215    		}			     	    					   
;;;216     	}
;;;217        TIM_ClearITPendingBit(TIM5, TIM_IT_CC1|TIM_IT_Update); 
0000a8  2103              MOVS     r1,#3
0000aa  4803              LDR      r0,|L6.184|
0000ac  f7fffffe          BL       TIM_ClearITPendingBit
;;;218    }
0000b0  bd10              POP      {r4,pc}
;;;219    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L6.180|
                          DCD      TIM5CH1_CAPTURE_STA
                  |L6.184|
                          DCD      0x40000c00
                  |L6.188|
                          DCD      TIM5CH1_CAPTURE_VAL

                          AREA ||i.TIM6_IRQHandler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  TIM6_IRQHandler PROC
;;;269    //定时器6中断服务程序	 
;;;270    void TIM6_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;271    { 		    		  			    
;;;272    	if (TIM_GetITStatus(TIM6, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 
000002  2101              MOVS     r1,#1
000004  4806              LDR      r0,|L7.32|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b120              CBZ      r0,|L7.22|
;;;273    	{				    
;;;274    		printf("step:%dfps\r\n",ov_sta);	//打印帧率				   				     	    	
00000c  4805              LDR      r0,|L7.36|
00000e  7801              LDRB     r1,[r0,#0]  ; ov_sta
000010  a005              ADR      r0,|L7.40|
000012  f7fffffe          BL       __2printf
                  |L7.22|
;;;275    	}				   
;;;276    	TIM_ClearITPendingBit(TIM6, TIM_IT_Update  );  //清除TIMx的中断待处理位:TIM 中断源 	    
000016  2101              MOVS     r1,#1
000018  4801              LDR      r0,|L7.32|
00001a  f7fffffe          BL       TIM_ClearITPendingBit
;;;277    }
00001e  bd10              POP      {r4,pc}
;;;278    //基本定时器6中断初始化
                          ENDP

                  |L7.32|
                          DCD      0x40001000
                  |L7.36|
                          DCD      ov_sta
                  |L7.40|
000028  73746570          DCB      "step:%dfps\r\n",0
00002c  3a256466
000030  70730d0a
000034  00      
000035  00                DCB      0
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.TIM6_Int_Init||, CODE, READONLY, ALIGN=2

                  TIM6_Int_Init PROC
;;;282    //这里使用的是定时器3!
;;;283    void TIM6_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;284    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;285      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;286    	NVIC_InitTypeDef NVIC_InitStructure;
;;;287    
;;;288    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE); //时钟使能
000006  2101              MOVS     r1,#1
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;289    
;;;290    	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 计数到5000为500ms
00000e  f8ad5008          STRH     r5,[sp,#8]
;;;291    	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率  
000012  f8ad4004          STRH     r4,[sp,#4]
;;;292    	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
000016  2000              MOVS     r0,#0
000018  f8ad000a          STRH     r0,[sp,#0xa]
;;;293    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
00001c  f8ad0006          STRH     r0,[sp,#6]
;;;294    	TIM_TimeBaseInit(TIM6, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000020  a901              ADD      r1,sp,#4
000022  480e              LDR      r0,|L8.92|
000024  f7fffffe          BL       TIM_TimeBaseInit
;;;295     
;;;296    	TIM_ITConfig( TIM6,TIM_IT_Update|TIM_IT_Trigger,ENABLE);//使能定时器6更新触发中断
000028  2201              MOVS     r2,#1
00002a  2141              MOVS     r1,#0x41
00002c  480b              LDR      r0,|L8.92|
00002e  f7fffffe          BL       TIM_ITConfig
;;;297     
;;;298    	TIM_Cmd(TIM6, ENABLE);  //使能TIMx外设
000032  2101              MOVS     r1,#1
000034  4809              LDR      r0,|L8.92|
000036  f7fffffe          BL       TIM_Cmd
;;;299     	
;;;300      NVIC_InitStructure.NVIC_IRQChannel = TIM6_IRQn;  //TIM3中断
00003a  2036              MOVS     r0,#0x36
00003c  f88d0000          STRB     r0,[sp,#0]
;;;301    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;  //先占优先级4级
000040  2004              MOVS     r0,#4
000042  f88d0001          STRB     r0,[sp,#1]
;;;302    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级
000046  2003              MOVS     r0,#3
000048  f88d0002          STRB     r0,[sp,#2]
;;;303    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能
00004c  2001              MOVS     r0,#1
00004e  f88d0003          STRB     r0,[sp,#3]
;;;304    	NVIC_Init(&NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 									 
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       NVIC_Init
;;;305    }	 
000058  bd7f              POP      {r0-r6,pc}
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      0x40001000

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;25     //}
;;;26     void TIM7_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;27     { 	
;;;28     	printf("now in TIM7\r\n");
000002  a00d              ADR      r0,|L9.56|
000004  f7fffffe          BL       __2printf
;;;29     	if (TIM_GetITStatus(TIM7, TIM_IT_Update) != RESET)
000008  2101              MOVS     r1,#1
00000a  480f              LDR      r0,|L9.72|
00000c  f7fffffe          BL       TIM_GetITStatus
000010  b180              CBZ      r0,|L9.52|
;;;30     	{
;;;31     				printf("set flag\r\n");
000012  a00e              ADR      r0,|L9.76|
000014  f7fffffe          BL       __2printf
;;;32     				USART3_RX_STA|=1<<15;	
000018  480f              LDR      r0,|L9.88|
00001a  8800              LDRH     r0,[r0,#0]  ; USART3_RX_STA
00001c  f4404000          ORR      r0,r0,#0x8000
000020  490d              LDR      r1,|L9.88|
000022  8008              STRH     r0,[r1,#0]
;;;33     				TIM_Cmd(TIM7, DISABLE);  
000024  2100              MOVS     r1,#0
000026  4808              LDR      r0,|L9.72|
000028  f7fffffe          BL       TIM_Cmd
;;;34     				TIM_ClearITPendingBit(TIM7, TIM_IT_Update  );   
00002c  2101              MOVS     r1,#1
00002e  4806              LDR      r0,|L9.72|
000030  f7fffffe          BL       TIM_ClearITPendingBit
                  |L9.52|
;;;35     	}	    
;;;36     }
000034  bd10              POP      {r4,pc}
;;;37     void TIM7_Int_Init(u16 arr,u16 psc)
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
000038  6e6f7720          DCB      "now in TIM7\r\n",0
00003c  696e2054
000040  494d370d
000044  0a00    
000046  00                DCB      0
000047  00                DCB      0
                  |L9.72|
                          DCD      0x40001400
                  |L9.76|
00004c  73657420          DCB      "set flag\r\n",0
000050  666c6167
000054  0d0a00  
000057  00                DCB      0
                  |L9.88|
                          DCD      USART3_RX_STA

                          AREA ||i.TIM7_Int_Init||, CODE, READONLY, ALIGN=2

                  TIM7_Int_Init PROC
;;;36     }
;;;37     void TIM7_Int_Init(u16 arr,u16 psc)
000000  b57f              PUSH     {r0-r6,lr}
;;;38     {	
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;39     	NVIC_InitTypeDef NVIC_InitStructure;
;;;40     	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;41     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);   
000006  2101              MOVS     r1,#1
000008  2020              MOVS     r0,#0x20
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;42     	TIM_TimeBaseStructure.TIM_Period = arr;	
00000e  f8ad5004          STRH     r5,[sp,#4]
;;;43     	TIM_TimeBaseStructure.TIM_Prescaler =psc;
000012  f8ad4000          STRH     r4,[sp,#0]
;;;44     	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; 
000016  2000              MOVS     r0,#0
000018  f8ad0006          STRH     r0,[sp,#6]
;;;45     	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
00001c  f8ad0002          STRH     r0,[sp,#2]
;;;46     	TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure);
000020  4669              MOV      r1,sp
000022  480e              LDR      r0,|L10.92|
000024  f7fffffe          BL       TIM_TimeBaseInit
;;;47     	TIM_ITConfig(TIM7,TIM_IT_Update,ENABLE ); 
000028  2201              MOVS     r2,#1
00002a  4611              MOV      r1,r2
00002c  480b              LDR      r0,|L10.92|
00002e  f7fffffe          BL       TIM_ITConfig
;;;48     	TIM_Cmd(TIM7,ENABLE);
000032  2101              MOVS     r1,#1
000034  4809              LDR      r0,|L10.92|
000036  f7fffffe          BL       TIM_Cmd
;;;49     	NVIC_InitStructure.NVIC_IRQChannel = TIM7_IRQn;
00003a  2037              MOVS     r0,#0x37
00003c  f88d000c          STRB     r0,[sp,#0xc]
;;;50     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0 ;
000040  2000              MOVS     r0,#0
000042  f88d000d          STRB     r0,[sp,#0xd]
;;;51     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
000046  2002              MOVS     r0,#2
000048  f88d000e          STRB     r0,[sp,#0xe]
;;;52     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00004c  2001              MOVS     r0,#1
00004e  f88d000f          STRB     r0,[sp,#0xf]
;;;53     	NVIC_Init(&NVIC_InitStructure);
000052  a803              ADD      r0,sp,#0xc
000054  f7fffffe          BL       NVIC_Init
;;;54     }
000058  bd7f              POP      {r0-r6,pc}
;;;55     void TIM3_Int_Init(u16 arr,u16 psc)
                          ENDP

00005a  0000              DCW      0x0000
                  |L10.92|
                          DCD      0x40001400

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  TIM5_ICInitStructure
                          %        10

                          AREA ||.data||, DATA, ALIGN=1

                  TIM5CH1_CAPTURE_STA
000000  0000              DCB      0x00,0x00
                  TIM5CH1_CAPTURE_VAL
000002  0000              DCB      0x00,0x00
