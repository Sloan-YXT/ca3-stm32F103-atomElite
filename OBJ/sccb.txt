; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\sccb.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\sccb.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\ATK-ESP8266 -I..\CORE -I..\FATFS\src -I..\FATFS\exfuns -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\LED -I..\HARDWARE\SDIO -I..\HARDWARE\SPI -I..\HARDWARE\TIMER -I..\HARDWARE\TOUCH -I..\HARDWARE\USART3 -I..\HARDWARE\W25QXX -I..\MALLOC -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\TEXT -I..\USER -I..\USMART -I..\PICTURE -I..\HARDWARE\OV7725 -I..\HARDWARE\EXTI -I..\HARDWARE\BEEP -I..\HARDWARE\DHT11 -I.\RTE\_Target_1 -ID:\Users\86132\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\sccb.crf ..\HARDWARE\OV7725\sccb.c]
                          THUMB

                          AREA ||i.SCCB_Init||, CODE, READONLY, ALIGN=2

                  SCCB_Init PROC
;;;76     
;;;4      void SCCB_Init(void)
000000  b508              PUSH     {r3,lr}
;;;5      {			
;;;6       	GPIO_InitTypeDef  GPIO_InitStructure;
;;;7       	
;;;8       	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOG, ENABLE);	 //使能PB端口时钟
000002  2101              MOVS     r1,#1
000004  f44f7090          MOV      r0,#0x120
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;9      	
;;;10       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;				 // 端口配置
00000c  f44f5000          MOV      r0,#0x2000
000010  f8ad0000          STRH     r0,[sp,#0]
;;;11      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 		 //输入
000014  2048              MOVS     r0,#0x48
000016  f88d0003          STRB     r0,[sp,#3]
;;;12      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001a  2003              MOVS     r0,#3
00001c  f88d0002          STRB     r0,[sp,#2]
;;;13      	GPIO_Init(GPIOG, &GPIO_InitStructure);
000020  4669              MOV      r1,sp
000022  4811              LDR      r0,|L1.104|
000024  f7fffffe          BL       GPIO_Init
;;;14      	GPIO_SetBits(GPIOG,GPIO_Pin_13);						 // 输出高
000028  f44f5100          MOV      r1,#0x2000
00002c  480e              LDR      r0,|L1.104|
00002e  f7fffffe          BL       GPIO_SetBits
;;;15     
;;;16     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;				 // 端口配置
000032  2008              MOVS     r0,#8
000034  f8ad0000          STRH     r0,[sp,#0]
;;;17      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //输输出
000038  2010              MOVS     r0,#0x10
00003a  f88d0003          STRB     r0,[sp,#3]
;;;18      	GPIO_Init(GPIOD, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  480a              LDR      r0,|L1.108|
000042  f7fffffe          BL       GPIO_Init
;;;19      	GPIO_SetBits(GPIOD,GPIO_Pin_3);						 // 输出高
000046  2108              MOVS     r1,#8
000048  4808              LDR      r0,|L1.108|
00004a  f7fffffe          BL       GPIO_SetBits
;;;20      
;;;21     	SCCB_SDA_OUT();	   
00004e  4806              LDR      r0,|L1.104|
000050  6840              LDR      r0,[r0,#4]
000052  f4200070          BIC      r0,r0,#0xf00000
000056  4904              LDR      r1,|L1.104|
000058  6048              STR      r0,[r1,#4]
00005a  4608              MOV      r0,r1
00005c  6840              LDR      r0,[r0,#4]
00005e  f4401040          ORR      r0,r0,#0x300000
000062  6048              STR      r0,[r1,#4]
;;;22     }			 
000064  bd08              POP      {r3,pc}
;;;23     
                          ENDP

000066  0000              DCW      0x0000
                  |L1.104|
                          DCD      0x40012000
                  |L1.108|
                          DCD      0x40011400

                          AREA ||i.SCCB_No_Ack||, CODE, READONLY, ALIGN=2

                  SCCB_No_Ack PROC
;;;49     //产生NA信号
;;;50     void SCCB_No_Ack(void)
000000  b510              PUSH     {r4,lr}
;;;51     {
;;;52     	delay_us(50);
000002  2032              MOVS     r0,#0x32
000004  f7fffffe          BL       delay_us
;;;53     	SCCB_SDA=1;	
000008  2001              MOVS     r0,#1
00000a  490b              LDR      r1,|L2.56|
00000c  6008              STR      r0,[r1,#0]
;;;54     	SCCB_SCL=1;	
00000e  490b              LDR      r1,|L2.60|
000010  f8c1018c          STR      r0,[r1,#0x18c]
;;;55     	delay_us(50);
000014  2032              MOVS     r0,#0x32
000016  f7fffffe          BL       delay_us
;;;56     	SCCB_SCL=0;	
00001a  2000              MOVS     r0,#0
00001c  4908              LDR      r1,|L2.64|
00001e  6008              STR      r0,[r1,#0]
;;;57     	delay_us(50);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       delay_us
;;;58     	SCCB_SDA=0;	
000026  2000              MOVS     r0,#0
000028  4906              LDR      r1,|L2.68|
00002a  f8c101b4          STR      r0,[r1,#0x1b4]
;;;59     	delay_us(50);
00002e  2032              MOVS     r0,#0x32
000030  f7fffffe          BL       delay_us
;;;60     }
000034  bd10              POP      {r4,pc}
;;;61     //SCCB,写入一个字节
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x422401b4
                  |L2.60|
                          DCD      0x42228000
                  |L2.64|
                          DCD      0x4222818c
                  |L2.68|
                          DCD      0x42240000

                          AREA ||i.SCCB_RD_Byte||, CODE, READONLY, ALIGN=2

                  SCCB_RD_Byte PROC
;;;88     //返回值:读到的数据
;;;89     u8 SCCB_RD_Byte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;90     {
;;;91     	u8 temp=0,j;    
000002  2400              MOVS     r4,#0
;;;92     	SCCB_SDA_IN();		//设置SDA为输入  
000004  4818              LDR      r0,|L3.104|
000006  6840              LDR      r0,[r0,#4]
000008  f4200070          BIC      r0,r0,#0xf00000
00000c  4916              LDR      r1,|L3.104|
00000e  6048              STR      r0,[r1,#4]
000010  4608              MOV      r0,r1
000012  6840              LDR      r0,[r0,#4]
000014  f4400000          ORR      r0,r0,#0x800000
000018  6048              STR      r0,[r1,#4]
;;;93     	for(j=8;j>0;j--) 	//循环8次接收数据
00001a  2508              MOVS     r5,#8
00001c  e015              B        |L3.74|
                  |L3.30|
;;;94     	{		     	  
;;;95     		delay_us(50);
00001e  2032              MOVS     r0,#0x32
000020  f7fffffe          BL       delay_us
;;;96     		SCCB_SCL=1;
000024  2001              MOVS     r0,#1
000026  4911              LDR      r1,|L3.108|
000028  6008              STR      r0,[r1,#0]
;;;97     		temp=temp<<1;
00002a  0660              LSLS     r0,r4,#25
00002c  0e04              LSRS     r4,r0,#24
;;;98     		if(SCCB_READ_SDA)temp++;   
00002e  4810              LDR      r0,|L3.112|
000030  f8d00134          LDR      r0,[r0,#0x134]
000034  b108              CBZ      r0,|L3.58|
000036  1c60              ADDS     r0,r4,#1
000038  b2c4              UXTB     r4,r0
                  |L3.58|
;;;99     		delay_us(50);
00003a  2032              MOVS     r0,#0x32
00003c  f7fffffe          BL       delay_us
;;;100    		SCCB_SCL=0;
000040  2000              MOVS     r0,#0
000042  490a              LDR      r1,|L3.108|
000044  6008              STR      r0,[r1,#0]
000046  1e68              SUBS     r0,r5,#1              ;93
000048  b2c5              UXTB     r5,r0                 ;93
                  |L3.74|
00004a  2d00              CMP      r5,#0                 ;93
00004c  dce7              BGT      |L3.30|
;;;101    	}	
;;;102    	SCCB_SDA_OUT();		//设置SDA为输出    
00004e  4806              LDR      r0,|L3.104|
000050  6840              LDR      r0,[r0,#4]
000052  f4200070          BIC      r0,r0,#0xf00000
000056  4904              LDR      r1,|L3.104|
000058  6048              STR      r0,[r1,#4]
00005a  4608              MOV      r0,r1
00005c  6840              LDR      r0,[r0,#4]
00005e  f4401040          ORR      r0,r0,#0x300000
000062  6048              STR      r0,[r1,#4]
;;;103    	return temp;
000064  4620              MOV      r0,r4
;;;104    } 							    
000066  bd70              POP      {r4-r6,pc}
;;;105    //写寄存器
                          ENDP

                  |L3.104|
                          DCD      0x40012000
                  |L3.108|
                          DCD      0x4222818c
                  |L3.112|
                          DCD      0x42240000

                          AREA ||i.SCCB_RD_Reg||, CODE, READONLY, ALIGN=1

                  SCCB_RD_Reg PROC
;;;120    //返回值:读到的寄存器值
;;;121    u8 SCCB_RD_Reg(u8 reg)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  4604              MOV      r4,r0
;;;123    	u8 val=0;
000004  2500              MOVS     r5,#0
;;;124    	SCCB_Start(); 				//启动SCCB传输
000006  f7fffffe          BL       SCCB_Start
;;;125    	SCCB_WR_Byte(SCCB_ID);		//写器件ID	  
00000a  2042              MOVS     r0,#0x42
00000c  f7fffffe          BL       SCCB_WR_Byte
;;;126    	delay_us(100);	 
000010  2064              MOVS     r0,#0x64
000012  f7fffffe          BL       delay_us
;;;127      	SCCB_WR_Byte(reg);			//写寄存器地址	  
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       SCCB_WR_Byte
;;;128    	delay_us(100);	  
00001c  2064              MOVS     r0,#0x64
00001e  f7fffffe          BL       delay_us
;;;129    	SCCB_Stop();   
000022  f7fffffe          BL       SCCB_Stop
;;;130    	delay_us(100);	   
000026  2064              MOVS     r0,#0x64
000028  f7fffffe          BL       delay_us
;;;131    	//设置寄存器地址后，才是读
;;;132    	SCCB_Start();
00002c  f7fffffe          BL       SCCB_Start
;;;133    	SCCB_WR_Byte(SCCB_ID|0X01);	//发送读命令	  
000030  2043              MOVS     r0,#0x43
000032  f7fffffe          BL       SCCB_WR_Byte
;;;134    	delay_us(100);
000036  2064              MOVS     r0,#0x64
000038  f7fffffe          BL       delay_us
;;;135      	val=SCCB_RD_Byte();		 	//读取数据
00003c  f7fffffe          BL       SCCB_RD_Byte
000040  4605              MOV      r5,r0
;;;136      	SCCB_No_Ack();
000042  f7fffffe          BL       SCCB_No_Ack
;;;137      	SCCB_Stop();
000046  f7fffffe          BL       SCCB_Stop
;;;138      	return val;
00004a  4628              MOV      r0,r5
;;;139    }
00004c  bd70              POP      {r4-r6,pc}
;;;140    
                          ENDP


                          AREA ||i.SCCB_Start||, CODE, READONLY, ALIGN=2

                  SCCB_Start PROC
;;;26     //在激活状态下,SDA和SCL均为低电平
;;;27     void SCCB_Start(void)
000000  b510              PUSH     {r4,lr}
;;;28     {
;;;29         SCCB_SDA=1;     //数据线高电平	   
000002  2001              MOVS     r0,#1
000004  4909              LDR      r1,|L5.44|
000006  6008              STR      r0,[r1,#0]
;;;30         SCCB_SCL=1;	    //在时钟线高的时候数据线由高至低
000008  4909              LDR      r1,|L5.48|
00000a  f8c1018c          STR      r0,[r1,#0x18c]
;;;31         delay_us(50);  
00000e  2032              MOVS     r0,#0x32
000010  f7fffffe          BL       delay_us
;;;32         SCCB_SDA=0;
000014  2000              MOVS     r0,#0
000016  4905              LDR      r1,|L5.44|
000018  6008              STR      r0,[r1,#0]
;;;33         delay_us(50);	 
00001a  2032              MOVS     r0,#0x32
00001c  f7fffffe          BL       delay_us
;;;34         SCCB_SCL=0;	    //数据线恢复低电平，单操作函数必要	  
000020  2000              MOVS     r0,#0
000022  4903              LDR      r1,|L5.48|
000024  f8c1018c          STR      r0,[r1,#0x18c]
;;;35     }
000028  bd10              POP      {r4,pc}
;;;36     
                          ENDP

00002a  0000              DCW      0x0000
                  |L5.44|
                          DCD      0x422401b4
                  |L5.48|
                          DCD      0x42228000

                          AREA ||i.SCCB_Stop||, CODE, READONLY, ALIGN=2

                  SCCB_Stop PROC
;;;39     //空闲状况下,SDA,SCL均为高电平
;;;40     void SCCB_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;41     {
;;;42         SCCB_SDA=0;
000002  2000              MOVS     r0,#0
000004  4909              LDR      r1,|L6.44|
000006  6008              STR      r0,[r1,#0]
;;;43         delay_us(50);	 
000008  2032              MOVS     r0,#0x32
00000a  f7fffffe          BL       delay_us
;;;44         SCCB_SCL=1;	
00000e  2001              MOVS     r0,#1
000010  4907              LDR      r1,|L6.48|
000012  f8c1018c          STR      r0,[r1,#0x18c]
;;;45         delay_us(50); 
000016  2032              MOVS     r0,#0x32
000018  f7fffffe          BL       delay_us
;;;46         SCCB_SDA=1;	
00001c  2001              MOVS     r0,#1
00001e  4903              LDR      r1,|L6.44|
000020  6008              STR      r0,[r1,#0]
;;;47         delay_us(50);
000022  2032              MOVS     r0,#0x32
000024  f7fffffe          BL       delay_us
;;;48     }  
000028  bd10              POP      {r4,pc}
;;;49     //产生NA信号
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x422401b4
                  |L6.48|
                          DCD      0x42228000

                          AREA ||i.SCCB_WR_Byte||, CODE, READONLY, ALIGN=2

                  SCCB_WR_Byte PROC
;;;62     //返回值:0,成功;1,失败. 
;;;63     u8 SCCB_WR_Byte(u8 dat)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {
000002  4604              MOV      r4,r0
;;;65     	u8 j,res;	 
;;;66     	for(j=0;j<8;j++) //循环8次发送数据
000004  2600              MOVS     r6,#0
000006  e01a              B        |L7.62|
                  |L7.8|
;;;67     	{
;;;68     		if(dat&0x80)SCCB_SDA=1;	
000008  f0040080          AND      r0,r4,#0x80
00000c  b118              CBZ      r0,|L7.22|
00000e  2001              MOVS     r0,#1
000010  4921              LDR      r1,|L7.152|
000012  6008              STR      r0,[r1,#0]
000014  e002              B        |L7.28|
                  |L7.22|
;;;69     		else SCCB_SDA=0;
000016  2000              MOVS     r0,#0
000018  491f              LDR      r1,|L7.152|
00001a  6008              STR      r0,[r1,#0]
                  |L7.28|
;;;70     		dat<<=1;
00001c  0660              LSLS     r0,r4,#25
00001e  0e04              LSRS     r4,r0,#24
;;;71     		delay_us(50);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       delay_us
;;;72     		SCCB_SCL=1;	
000026  2001              MOVS     r0,#1
000028  491c              LDR      r1,|L7.156|
00002a  6008              STR      r0,[r1,#0]
;;;73     		delay_us(50);
00002c  2032              MOVS     r0,#0x32
00002e  f7fffffe          BL       delay_us
;;;74     		SCCB_SCL=0;		   
000032  2000              MOVS     r0,#0
000034  491a              LDR      r1,|L7.160|
000036  f8c1018c          STR      r0,[r1,#0x18c]
00003a  1c70              ADDS     r0,r6,#1              ;66
00003c  b2c6              UXTB     r6,r0                 ;66
                  |L7.62|
00003e  2e08              CMP      r6,#8                 ;66
000040  dbe2              BLT      |L7.8|
;;;75     	}			 
;;;76     	SCCB_SDA_IN();		//设置SDA为输入 
000042  4818              LDR      r0,|L7.164|
000044  6840              LDR      r0,[r0,#4]
000046  f4200070          BIC      r0,r0,#0xf00000
00004a  4916              LDR      r1,|L7.164|
00004c  6048              STR      r0,[r1,#4]
00004e  4608              MOV      r0,r1
000050  6840              LDR      r0,[r0,#4]
000052  f4400000          ORR      r0,r0,#0x800000
000056  6048              STR      r0,[r1,#4]
;;;77     	delay_us(50);
000058  2032              MOVS     r0,#0x32
00005a  f7fffffe          BL       delay_us
;;;78     	SCCB_SCL=1;			//接收第九位,以判断是否发送成功
00005e  2001              MOVS     r0,#1
000060  490e              LDR      r1,|L7.156|
000062  6008              STR      r0,[r1,#0]
;;;79     	delay_us(50);
000064  2032              MOVS     r0,#0x32
000066  f7fffffe          BL       delay_us
;;;80     	if(SCCB_READ_SDA)res=1;  //SDA=1发送失败，返回1
00006a  480f              LDR      r0,|L7.168|
00006c  f8d00134          LDR      r0,[r0,#0x134]
000070  b108              CBZ      r0,|L7.118|
000072  2501              MOVS     r5,#1
000074  e000              B        |L7.120|
                  |L7.118|
;;;81     	else res=0;         //SDA=0发送成功，返回0
000076  2500              MOVS     r5,#0
                  |L7.120|
;;;82     	SCCB_SCL=0;		 
000078  2000              MOVS     r0,#0
00007a  4908              LDR      r1,|L7.156|
00007c  6008              STR      r0,[r1,#0]
;;;83     	SCCB_SDA_OUT();		//设置SDA为输出    
00007e  4809              LDR      r0,|L7.164|
000080  6840              LDR      r0,[r0,#4]
000082  f4200070          BIC      r0,r0,#0xf00000
000086  4907              LDR      r1,|L7.164|
000088  6048              STR      r0,[r1,#4]
00008a  4608              MOV      r0,r1
00008c  6840              LDR      r0,[r0,#4]
00008e  f4401040          ORR      r0,r0,#0x300000
000092  6048              STR      r0,[r1,#4]
;;;84     	return res;  
000094  4628              MOV      r0,r5
;;;85     }	 
000096  bd70              POP      {r4-r6,pc}
;;;86     //SCCB 读取一个字节
                          ENDP

                  |L7.152|
                          DCD      0x422401b4
                  |L7.156|
                          DCD      0x4222818c
                  |L7.160|
                          DCD      0x42228000
                  |L7.164|
                          DCD      0x40012000
                  |L7.168|
                          DCD      0x42240000

                          AREA ||i.SCCB_WR_Reg||, CODE, READONLY, ALIGN=1

                  SCCB_WR_Reg PROC
;;;106    //返回值:0,成功;1,失败.
;;;107    u8 SCCB_WR_Reg(u8 reg,u8 data)
000000  b570              PUSH     {r4-r6,lr}
;;;108    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;109    	u8 res=0;
000006  2600              MOVS     r6,#0
;;;110    	SCCB_Start(); 					//启动SCCB传输
000008  f7fffffe          BL       SCCB_Start
;;;111    	if(SCCB_WR_Byte(SCCB_ID))res=1;	//写器件ID	  
00000c  2042              MOVS     r0,#0x42
00000e  f7fffffe          BL       SCCB_WR_Byte
000012  b100              CBZ      r0,|L8.22|
000014  2601              MOVS     r6,#1
                  |L8.22|
;;;112    	delay_us(100);
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       delay_us
;;;113      	if(SCCB_WR_Byte(reg))res=1;		//写寄存器地址	  
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       SCCB_WR_Byte
000022  b100              CBZ      r0,|L8.38|
000024  2601              MOVS     r6,#1
                  |L8.38|
;;;114    	delay_us(100);
000026  2064              MOVS     r0,#0x64
000028  f7fffffe          BL       delay_us
;;;115      	if(SCCB_WR_Byte(data))res=1; 	//写数据	 
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SCCB_WR_Byte
000032  b100              CBZ      r0,|L8.54|
000034  2601              MOVS     r6,#1
                  |L8.54|
;;;116      	SCCB_Stop();	  
000036  f7fffffe          BL       SCCB_Stop
;;;117      	return	res;
00003a  4630              MOV      r0,r6
;;;118    }		  					    
00003c  bd70              POP      {r4-r6,pc}
;;;119    //读寄存器
                          ENDP

