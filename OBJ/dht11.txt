; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\dht11.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\dht11.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\ATK-ESP8266 -I..\CORE -I..\FATFS\src -I..\FATFS\exfuns -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\LED -I..\HARDWARE\SDIO -I..\HARDWARE\SPI -I..\HARDWARE\TIMER -I..\HARDWARE\TOUCH -I..\HARDWARE\USART3 -I..\HARDWARE\W25QXX -I..\MALLOC -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\TEXT -I..\USER -I..\USMART -I..\PICTURE -I..\HARDWARE\OV7725 -I..\HARDWARE\EXTI -I..\HARDWARE\BEEP -I..\HARDWARE\DHT11 -I.\RTE\_Target_1 -ID:\Users\86132\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\dht11.crf ..\HARDWARE\DHT11\dht11.c]
                          THUMB

                          AREA ||i.DHT11_Check||, CODE, READONLY, ALIGN=2

                  DHT11_Check PROC
;;;13     //返回0:存在
;;;14     u8 DHT11_Check(void) 	   
000000  b510              PUSH     {r4,lr}
;;;15     {   
;;;16     	u8 retry=0;
000002  2400              MOVS     r4,#0
;;;17     	DHT11_IO_IN();//SET INPUT	 
000004  4815              LDR      r0,|L1.92|
000006  6840              LDR      r0,[r0,#4]
000008  f4204070          BIC      r0,r0,#0xf000
00000c  4913              LDR      r1,|L1.92|
00000e  6048              STR      r0,[r1,#4]
000010  4608              MOV      r0,r1
000012  6840              LDR      r0,[r0,#4]
000014  f4404000          ORR      r0,r0,#0x8000
000018  6048              STR      r0,[r1,#4]
;;;18         while (DHT11_DQ_IN&&retry<100)//DHT11会拉低40~80us
00001a  e004              B        |L1.38|
                  |L1.28|
;;;19     	{
;;;20     		retry++;
00001c  1c60              ADDS     r0,r4,#1
00001e  b2c4              UXTB     r4,r0
;;;21     		delay_us(1);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       delay_us
                  |L1.38|
000026  480e              LDR      r0,|L1.96|
000028  6800              LDR      r0,[r0,#0]            ;18
00002a  b108              CBZ      r0,|L1.48|
00002c  2c64              CMP      r4,#0x64              ;18
00002e  dbf5              BLT      |L1.28|
                  |L1.48|
;;;22     	};	 
;;;23     	if(retry>=100)return 1;
000030  2c64              CMP      r4,#0x64
000032  db01              BLT      |L1.56|
000034  2001              MOVS     r0,#1
                  |L1.54|
;;;24     	else retry=0;
;;;25         while (!DHT11_DQ_IN&&retry<100)//DHT11拉低后会再次拉高40~80us
;;;26     	{
;;;27     		retry++;
;;;28     		delay_us(1);
;;;29     	};
;;;30     	if(retry>=100)return 1;	    
;;;31     	return 0;
;;;32     }
000036  bd10              POP      {r4,pc}
                  |L1.56|
000038  2400              MOVS     r4,#0                 ;24
00003a  e004              B        |L1.70|
                  |L1.60|
00003c  1c60              ADDS     r0,r4,#1              ;27
00003e  b2c4              UXTB     r4,r0                 ;27
000040  2001              MOVS     r0,#1                 ;28
000042  f7fffffe          BL       delay_us
                  |L1.70|
000046  4806              LDR      r0,|L1.96|
000048  6800              LDR      r0,[r0,#0]            ;25
00004a  b908              CBNZ     r0,|L1.80|
00004c  2c64              CMP      r4,#0x64              ;25
00004e  dbf5              BLT      |L1.60|
                  |L1.80|
000050  2c64              CMP      r4,#0x64              ;30
000052  db01              BLT      |L1.88|
000054  2001              MOVS     r0,#1                 ;30
000056  e7ee              B        |L1.54|
                  |L1.88|
000058  2000              MOVS     r0,#0                 ;31
00005a  e7ec              B        |L1.54|
;;;33     //从DHT11读取一个位
                          ENDP

                  |L1.92|
                          DCD      0x40012000
                  |L1.96|
                          DCD      0x4224012c

                          AREA ||i.DHT11_Init||, CODE, READONLY, ALIGN=2

                  DHT11_Init PROC
;;;91     //返回0:存在    	 
;;;92     u8 DHT11_Init(void)
000000  b508              PUSH     {r3,lr}
;;;93     {	 
;;;94      	GPIO_InitTypeDef  GPIO_InitStructure;
;;;95      	
;;;96      	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOG, ENABLE);	 //使能PG端口时钟
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;97     	
;;;98      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;				 //PG11端口配置
00000a  f44f6000          MOV      r0,#0x800
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;99      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
000012  2010              MOVS     r0,#0x10
000014  f88d0003          STRB     r0,[sp,#3]
;;;100     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0002          STRB     r0,[sp,#2]
;;;101     	GPIO_Init(GPIOG, &GPIO_InitStructure);				 //初始化IO口
00001e  4669              MOV      r1,sp
000020  4806              LDR      r0,|L2.60|
000022  f7fffffe          BL       GPIO_Init
;;;102     	GPIO_SetBits(GPIOG,GPIO_Pin_11);						 //PG11 输出高
000026  f44f6100          MOV      r1,#0x800
00002a  4804              LDR      r0,|L2.60|
00002c  f7fffffe          BL       GPIO_SetBits
;;;103    			    
;;;104    	DHT11_Rst();  //复位DHT11
000030  f7fffffe          BL       DHT11_Rst
;;;105    	return DHT11_Check();//等待DHT11的回应
000034  f7fffffe          BL       DHT11_Check
;;;106    } 
000038  bd08              POP      {r3,pc}
;;;107    
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      0x40012000

                          AREA ||i.DHT11_Read_Bit||, CODE, READONLY, ALIGN=2

                  DHT11_Read_Bit PROC
;;;34     //返回值：1/0
;;;35     u8 DHT11_Read_Bit(void) 			 
000000  b510              PUSH     {r4,lr}
;;;36     {
;;;37      	u8 retry=0;
000002  2400              MOVS     r4,#0
;;;38     	while(DHT11_DQ_IN&&retry<100)//等待变为低电平
000004  e004              B        |L3.16|
                  |L3.6|
;;;39     	{
;;;40     		retry++;
000006  1c60              ADDS     r0,r4,#1
000008  b2c4              UXTB     r4,r0
;;;41     		delay_us(1);
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       delay_us
                  |L3.16|
000010  480d              LDR      r0,|L3.72|
000012  6800              LDR      r0,[r0,#0]            ;38
000014  b108              CBZ      r0,|L3.26|
000016  2c64              CMP      r4,#0x64              ;38
000018  dbf5              BLT      |L3.6|
                  |L3.26|
;;;42     	}
;;;43     	retry=0;
00001a  2400              MOVS     r4,#0
;;;44     	while(!DHT11_DQ_IN&&retry<100)//等待变高电平
00001c  e004              B        |L3.40|
                  |L3.30|
;;;45     	{
;;;46     		retry++;
00001e  1c60              ADDS     r0,r4,#1
000020  b2c4              UXTB     r4,r0
;;;47     		delay_us(1);
000022  2001              MOVS     r0,#1
000024  f7fffffe          BL       delay_us
                  |L3.40|
000028  4807              LDR      r0,|L3.72|
00002a  6800              LDR      r0,[r0,#0]            ;44
00002c  b908              CBNZ     r0,|L3.50|
00002e  2c64              CMP      r4,#0x64              ;44
000030  dbf5              BLT      |L3.30|
                  |L3.50|
;;;48     	}
;;;49     	delay_us(40);//等待40us
000032  2028              MOVS     r0,#0x28
000034  f7fffffe          BL       delay_us
;;;50     	if(DHT11_DQ_IN)return 1;
000038  4803              LDR      r0,|L3.72|
00003a  6800              LDR      r0,[r0,#0]
00003c  b108              CBZ      r0,|L3.66|
00003e  2001              MOVS     r0,#1
                  |L3.64|
;;;51     	else return 0;		   
;;;52     }
000040  bd10              POP      {r4,pc}
                  |L3.66|
000042  2000              MOVS     r0,#0                 ;51
000044  e7fc              B        |L3.64|
;;;53     //从DHT11读取一个字节
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      0x4224012c

                          AREA ||i.DHT11_Read_Byte||, CODE, READONLY, ALIGN=1

                  DHT11_Read_Byte PROC
;;;54     //返回值：读到的数据
;;;55     u8 DHT11_Read_Byte(void)    
000000  b570              PUSH     {r4-r6,lr}
;;;56     {        
;;;57         u8 i,dat;
;;;58         dat=0;
000002  2400              MOVS     r4,#0
;;;59     	for (i=0;i<8;i++) 
000004  2500              MOVS     r5,#0
000006  e006              B        |L4.22|
                  |L4.8|
;;;60     	{
;;;61        		dat<<=1; 
000008  0660              LSLS     r0,r4,#25
00000a  0e04              LSRS     r4,r0,#24
;;;62     	    dat|=DHT11_Read_Bit();
00000c  f7fffffe          BL       DHT11_Read_Bit
000010  4304              ORRS     r4,r4,r0
000012  1c68              ADDS     r0,r5,#1              ;59
000014  b2c5              UXTB     r5,r0                 ;59
                  |L4.22|
000016  2d08              CMP      r5,#8                 ;59
000018  dbf6              BLT      |L4.8|
;;;63        }						    
;;;64         return dat;
00001a  4620              MOV      r0,r4
;;;65     }
00001c  bd70              POP      {r4-r6,pc}
;;;66     //从DHT11读取一次数据
                          ENDP


                          AREA ||i.DHT11_Read_Data||, CODE, READONLY, ALIGN=1

                  DHT11_Read_Data PROC
;;;69     //返回值：0,正常;1,读取失败
;;;70     u8 DHT11_Read_Data(u16 *temp,u16 *humi)    
000000  b57c              PUSH     {r2-r6,lr}
;;;71     {        
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;72      	u8 buf[5];
;;;73     	u8 i;
;;;74     	DHT11_Rst();
000006  f7fffffe          BL       DHT11_Rst
;;;75     	if(DHT11_Check()==0)
00000a  f7fffffe          BL       DHT11_Check
00000e  bb38              CBNZ     r0,|L5.96|
;;;76     	{
;;;77     		for(i=0;i<5;i++)//读取40位数据
000010  2400              MOVS     r4,#0
000012  e005              B        |L5.32|
                  |L5.20|
;;;78     		{
;;;79     			buf[i]=DHT11_Read_Byte();
000014  f7fffffe          BL       DHT11_Read_Byte
000018  f80d0004          STRB     r0,[sp,r4]
00001c  1c60              ADDS     r0,r4,#1              ;77
00001e  b2c4              UXTB     r4,r0                 ;77
                  |L5.32|
000020  2c05              CMP      r4,#5                 ;77
000022  dbf7              BLT      |L5.20|
;;;80     		}
;;;81     		if((buf[0]+buf[1]+buf[2]+buf[3])==buf[4])
000024  f89d0000          LDRB     r0,[sp,#0]
000028  f89d1001          LDRB     r1,[sp,#1]
00002c  4408              ADD      r0,r0,r1
00002e  f89d1002          LDRB     r1,[sp,#2]
000032  4408              ADD      r0,r0,r1
000034  f89d1003          LDRB     r1,[sp,#3]
000038  4408              ADD      r0,r0,r1
00003a  f89d1004          LDRB     r1,[sp,#4]
00003e  4288              CMP      r0,r1
000040  d110              BNE      |L5.100|
;;;82     		{
;;;83     			*humi=buf[0]<<8|buf[1];
000042  f89d0001          LDRB     r0,[sp,#1]
000046  f89d1000          LDRB     r1,[sp,#0]
00004a  ea402001          ORR      r0,r0,r1,LSL #8
00004e  8030              STRH     r0,[r6,#0]
;;;84     			*temp=buf[2]<<8|buf[3];
000050  f89d0003          LDRB     r0,[sp,#3]
000054  f89d1002          LDRB     r1,[sp,#2]
000058  ea402001          ORR      r0,r0,r1,LSL #8
00005c  8028              STRH     r0,[r5,#0]
00005e  e001              B        |L5.100|
                  |L5.96|
;;;85     		}
;;;86     	}else return 1;
000060  2001              MOVS     r0,#1
                  |L5.98|
;;;87     	return 0;	    
;;;88     }
000062  bd7c              POP      {r2-r6,pc}
                  |L5.100|
000064  2000              MOVS     r0,#0                 ;87
000066  e7fc              B        |L5.98|
;;;89     //初始化DHT11的IO口 DQ 同时检测DHT11的存在
                          ENDP


                          AREA ||i.DHT11_Rst||, CODE, READONLY, ALIGN=2

                  DHT11_Rst PROC
;;;76     
;;;3      void DHT11_Rst(void)	   
000000  b510              PUSH     {r4,lr}
;;;4      {                 
;;;5      	DHT11_IO_OUT(); 	//SET OUTPUT
000002  480c              LDR      r0,|L6.52|
000004  6840              LDR      r0,[r0,#4]
000006  f4204070          BIC      r0,r0,#0xf000
00000a  490a              LDR      r1,|L6.52|
00000c  6048              STR      r0,[r1,#4]
00000e  4608              MOV      r0,r1
000010  6840              LDR      r0,[r0,#4]
000012  f4405040          ORR      r0,r0,#0x3000
000016  6048              STR      r0,[r1,#4]
;;;6          DHT11_DQ_OUT=0; 	//拉低DQ
000018  2000              MOVS     r0,#0
00001a  4907              LDR      r1,|L6.56|
00001c  6008              STR      r0,[r1,#0]
;;;7          delay_ms(20);    	//拉低至少18ms
00001e  2014              MOVS     r0,#0x14
000020  f7fffffe          BL       delay_ms
;;;8          DHT11_DQ_OUT=1; 	//DQ=1 
000024  2001              MOVS     r0,#1
000026  4905              LDR      r1,|L6.60|
000028  f8c101ac          STR      r0,[r1,#0x1ac]
;;;9      	delay_us(30);     	//主机拉高20~40us
00002c  201e              MOVS     r0,#0x1e
00002e  f7fffffe          BL       delay_us
;;;10     }
000032  bd10              POP      {r4,pc}
;;;11     //等待DHT11的回应
                          ENDP

                  |L6.52|
                          DCD      0x40012000
                  |L6.56|
                          DCD      0x422401ac
                  |L6.60|
                          DCD      0x42240000
