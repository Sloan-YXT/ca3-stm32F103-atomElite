; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\piclib.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\piclib.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\ATK-ESP8266 -I..\CORE -I..\FATFS\src -I..\FATFS\exfuns -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\LED -I..\HARDWARE\SDIO -I..\HARDWARE\SPI -I..\HARDWARE\TIMER -I..\HARDWARE\TOUCH -I..\HARDWARE\USART3 -I..\HARDWARE\W25QXX -I..\MALLOC -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\TEXT -I..\USER -I..\USMART -I..\PICTURE -I..\HARDWARE\OV7725 -I..\HARDWARE\EXTI -I..\HARDWARE\BEEP -I..\HARDWARE\DHT11 -I.\RTE\_Target_1 -ID:\Users\86132\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\piclib.crf ..\PICTURE\piclib.c]
                          THUMB

                          AREA ||i.ai_draw_init||, CODE, READONLY, ALIGN=2

                  ai_draw_init PROC
;;;80     //内部调用
;;;81     void ai_draw_init(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;82     {
;;;83     	float temp,temp1;	   
;;;84     	temp=(float)picinfo.S_Width/picinfo.ImgWidth;
000004  4940              LDR      r1,|L1.264|
000006  6848              LDR      r0,[r1,#4]  ; picinfo
000008  f7fffffe          BL       __aeabi_ui2f
00000c  4606              MOV      r6,r0
00000e  493e              LDR      r1,|L1.264|
000010  6948              LDR      r0,[r1,#0x14]  ; picinfo
000012  f7fffffe          BL       __aeabi_ui2f
000016  4607              MOV      r7,r0
000018  4631              MOV      r1,r6
00001a  f7fffffe          BL       __aeabi_fdiv
00001e  4604              MOV      r4,r0
;;;85     	temp1=(float)picinfo.S_Height/picinfo.ImgHeight;						 
000020  4939              LDR      r1,|L1.264|
000022  6888              LDR      r0,[r1,#8]  ; picinfo
000024  f7fffffe          BL       __aeabi_ui2f
000028  4606              MOV      r6,r0
00002a  4937              LDR      r1,|L1.264|
00002c  6908              LDR      r0,[r1,#0x10]  ; picinfo
00002e  f7fffffe          BL       __aeabi_ui2f
000032  4607              MOV      r7,r0
000034  4631              MOV      r1,r6
000036  f7fffffe          BL       __aeabi_fdiv
00003a  4605              MOV      r5,r0
;;;86     	if(temp<temp1)temp1=temp;//取较小的那个	 
00003c  4629              MOV      r1,r5
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       __aeabi_cfcmple
000044  d200              BCS      |L1.72|
000046  4625              MOV      r5,r4
                  |L1.72|
;;;87     	if(temp1>1)temp1=1;	  
000048  f04f517e          MOV      r1,#0x3f800000
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       __aeabi_cfrcmple
000052  d201              BCS      |L1.88|
000054  f04f557e          MOV      r5,#0x3f800000
                  |L1.88|
;;;88     	//使图片处于所给区域的中间
;;;89     	picinfo.S_XOFF+=(picinfo.S_Width-temp1*picinfo.ImgWidth)/2;
000058  492b              LDR      r1,|L1.264|
00005a  6848              LDR      r0,[r1,#4]  ; picinfo
00005c  f7fffffe          BL       __aeabi_ui2f
000060  4683              MOV      r11,r0
000062  4629              MOV      r1,r5
000064  f7fffffe          BL       __aeabi_fmul
000068  4681              MOV      r9,r0
00006a  4927              LDR      r1,|L1.264|
00006c  6948              LDR      r0,[r1,#0x14]  ; picinfo
00006e  f7fffffe          BL       __aeabi_ui2f
000072  4649              MOV      r1,r9
000074  9000              STR      r0,[sp,#0]
000076  f7fffffe          BL       __aeabi_fsub
00007a  4680              MOV      r8,r0
00007c  f04f4180          MOV      r1,#0x40000000
000080  f7fffffe          BL       __aeabi_fdiv
000084  4607              MOV      r7,r0
000086  4920              LDR      r1,|L1.264|
000088  6988              LDR      r0,[r1,#0x18]  ; picinfo
00008a  f7fffffe          BL       __aeabi_ui2f
00008e  4682              MOV      r10,r0
000090  4639              MOV      r1,r7
000092  f7fffffe          BL       __aeabi_fadd
000096  4606              MOV      r6,r0
000098  f7fffffe          BL       __aeabi_f2uiz
00009c  491a              LDR      r1,|L1.264|
00009e  6188              STR      r0,[r1,#0x18]  ; picinfo
;;;90     	picinfo.S_YOFF+=(picinfo.S_Height-temp1*picinfo.ImgHeight)/2;
0000a0  6888              LDR      r0,[r1,#8]  ; picinfo
0000a2  f7fffffe          BL       __aeabi_ui2f
0000a6  4683              MOV      r11,r0
0000a8  4629              MOV      r1,r5
0000aa  f7fffffe          BL       __aeabi_fmul
0000ae  4681              MOV      r9,r0
0000b0  4915              LDR      r1,|L1.264|
0000b2  6908              LDR      r0,[r1,#0x10]  ; picinfo
0000b4  f7fffffe          BL       __aeabi_ui2f
0000b8  4682              MOV      r10,r0
0000ba  4649              MOV      r1,r9
0000bc  f7fffffe          BL       __aeabi_fsub
0000c0  4680              MOV      r8,r0
0000c2  f04f4180          MOV      r1,#0x40000000
0000c6  f7fffffe          BL       __aeabi_fdiv
0000ca  4607              MOV      r7,r0
0000cc  490e              LDR      r1,|L1.264|
0000ce  69c8              LDR      r0,[r1,#0x1c]  ; picinfo
0000d0  f7fffffe          BL       __aeabi_ui2f
0000d4  4639              MOV      r1,r7
0000d6  9000              STR      r0,[sp,#0]
0000d8  f7fffffe          BL       __aeabi_fadd
0000dc  4606              MOV      r6,r0
0000de  f7fffffe          BL       __aeabi_f2uiz
0000e2  4909              LDR      r1,|L1.264|
0000e4  61c8              STR      r0,[r1,#0x1c]  ; picinfo
;;;91     	temp1*=8192;//扩大8192倍	 
0000e6  f04f418c          MOV      r1,#0x46000000
0000ea  4628              MOV      r0,r5
0000ec  f7fffffe          BL       __aeabi_fmul
0000f0  4605              MOV      r5,r0
;;;92     	picinfo.Div_Fac=temp1;
0000f2  4628              MOV      r0,r5
0000f4  f7fffffe          BL       __aeabi_f2uiz
0000f8  4903              LDR      r1,|L1.264|
0000fa  60c8              STR      r0,[r1,#0xc]  ; picinfo
;;;93     	picinfo.staticx=0xffff;
0000fc  f64f70ff          MOV      r0,#0xffff
000100  6208              STR      r0,[r1,#0x20]  ; picinfo
;;;94     	picinfo.staticy=0xffff;//放到一个不可能的值上面			 										    
000102  6248              STR      r0,[r1,#0x24]  ; picinfo
;;;95     }   
000104  e8bd8ff8          POP      {r3-r11,pc}
;;;96     //判断这个像素是否可以显示
                          ENDP

                  |L1.264|
                          DCD      picinfo

                          AREA ||i.ai_load_picfile||, CODE, READONLY, ALIGN=2

                  ai_load_picfile PROC
;;;116    //图片在开始和结束的坐标点范围内显示
;;;117    u8 ai_load_picfile(const u8 *filename,u16 x,u16 y,u16 width,u16 height,u8 fast)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;118    {	
000004  4682              MOV      r10,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  e9dd6b0a          LDRD     r6,r11,[sp,#0x28]
;;;119    	u8	res;//返回值
;;;120    	u8 temp;	
;;;121    	if((x+width)>picinfo.lcdwidth)return PIC_WINDOW_ERR;		//x坐标超范围了.
000010  1978              ADDS     r0,r7,r5
000012  492c              LDR      r1,|L2.196|
000014  8809              LDRH     r1,[r1,#0]  ; picinfo
000016  4288              CMP      r0,r1
000018  dd02              BLE      |L2.32|
00001a  2029              MOVS     r0,#0x29
                  |L2.28|
;;;122    	if((y+height)>picinfo.lcdheight)return PIC_WINDOW_ERR;		//y坐标超范围了.  
;;;123    	//得到显示方框大小	  	 
;;;124    	if(width==0||height==0)return PIC_WINDOW_ERR;	//窗口设定错误
;;;125    	picinfo.S_Height=height;
;;;126    	picinfo.S_Width=width;
;;;127    	//显示区域无效
;;;128    	if(picinfo.S_Height==0||picinfo.S_Width==0)
;;;129    	{
;;;130    		picinfo.S_Height=lcddev.height;
;;;131    		picinfo.S_Width=lcddev.width;
;;;132    		return FALSE;   
;;;133    	}
;;;134    	if(pic_phy.fillcolor==NULL)fast=0;//颜色填充函数未实现,不能快速显示
;;;135    	//显示的开始坐标点
;;;136    	picinfo.S_YOFF=y;
;;;137    	picinfo.S_XOFF=x;
;;;138    	//文件名传递		 
;;;139    	temp=f_typetell((u8*)filename);	//得到文件的类型
;;;140    	switch(temp)
;;;141    	{											  
;;;142    		case T_BMP:
;;;143    			res=stdbmp_decode(filename); 				//解码bmp	  	  
;;;144    			break;
;;;145    		case T_JPG:
;;;146    		case T_JPEG:
;;;147    			res=jpg_decode(filename,fast);				//解码JPG/JPEG	  	  
;;;148    			break;
;;;149    		case T_GIF:
;;;150    			res=gif_decode(filename,x,y,width,height);	//解码gif  	  
;;;151    			break;
;;;152    		default:
;;;153    	 		res=PIC_FORMAT_ERR;  						//非图片格式!!!  
;;;154    			break;
;;;155    	}  											   
;;;156    	return res;
;;;157    }
00001c  e8bd8ff8          POP      {r3-r11,pc}
                  |L2.32|
000020  eb080006          ADD      r0,r8,r6              ;122
000024  4927              LDR      r1,|L2.196|
000026  8849              LDRH     r1,[r1,#2]            ;122  ; picinfo
000028  4288              CMP      r0,r1                 ;122
00002a  dd01              BLE      |L2.48|
00002c  2029              MOVS     r0,#0x29              ;122
00002e  e7f5              B        |L2.28|
                  |L2.48|
000030  b105              CBZ      r5,|L2.52|
000032  b90e              CBNZ     r6,|L2.56|
                  |L2.52|
000034  2029              MOVS     r0,#0x29              ;124
000036  e7f1              B        |L2.28|
                  |L2.56|
000038  4822              LDR      r0,|L2.196|
00003a  6106              STR      r6,[r0,#0x10]         ;125  ; picinfo
00003c  6145              STR      r5,[r0,#0x14]         ;126  ; picinfo
00003e  6900              LDR      r0,[r0,#0x10]         ;128  ; picinfo
000040  b110              CBZ      r0,|L2.72|
000042  4820              LDR      r0,|L2.196|
000044  6940              LDR      r0,[r0,#0x14]         ;128  ; picinfo
000046  b940              CBNZ     r0,|L2.90|
                  |L2.72|
000048  481f              LDR      r0,|L2.200|
00004a  8840              LDRH     r0,[r0,#2]            ;130  ; lcddev
00004c  491d              LDR      r1,|L2.196|
00004e  6108              STR      r0,[r1,#0x10]         ;130  ; picinfo
000050  481d              LDR      r0,|L2.200|
000052  8800              LDRH     r0,[r0,#0]            ;131  ; lcddev
000054  6148              STR      r0,[r1,#0x14]         ;131  ; picinfo
000056  2000              MOVS     r0,#0                 ;132
000058  e7e0              B        |L2.28|
                  |L2.90|
00005a  481c              LDR      r0,|L2.204|
00005c  6900              LDR      r0,[r0,#0x10]         ;134  ; pic_phy
00005e  b908              CBNZ     r0,|L2.100|
000060  f04f0b00          MOV      r11,#0                ;134
                  |L2.100|
000064  4817              LDR      r0,|L2.196|
000066  f8c0801c          STR      r8,[r0,#0x1c]         ;136  ; picinfo
00006a  6187              STR      r7,[r0,#0x18]         ;137  ; picinfo
00006c  4650              MOV      r0,r10                ;139
00006e  f7fffffe          BL       f_typetell
000072  4681              MOV      r9,r0                 ;139
000074  f1b90f50          CMP      r9,#0x50              ;140
000078  d009              BEQ      |L2.142|
00007a  f1b90f51          CMP      r9,#0x51              ;140
00007e  d00b              BEQ      |L2.152|
000080  f1b90f52          CMP      r9,#0x52              ;140
000084  d009              BEQ      |L2.154|
000086  f1b90f53          CMP      r9,#0x53              ;140
00008a  d115              BNE      |L2.184|
00008c  e00b              B        |L2.166|
                  |L2.142|
00008e  4650              MOV      r0,r10                ;143
000090  f7fffffe          BL       stdbmp_decode
000094  4604              MOV      r4,r0                 ;143
000096  e011              B        |L2.188|
                  |L2.152|
000098  bf00              NOP                            ;146
                  |L2.154|
00009a  4659              MOV      r1,r11                ;147
00009c  4650              MOV      r0,r10                ;147
00009e  f7fffffe          BL       jpg_decode
0000a2  4604              MOV      r4,r0                 ;147
0000a4  e00a              B        |L2.188|
                  |L2.166|
0000a6  462b              MOV      r3,r5                 ;150
0000a8  4642              MOV      r2,r8                 ;150
0000aa  4639              MOV      r1,r7                 ;150
0000ac  4650              MOV      r0,r10                ;150
0000ae  9600              STR      r6,[sp,#0]            ;150
0000b0  f7fffffe          BL       gif_decode
0000b4  4604              MOV      r4,r0                 ;150
0000b6  e001              B        |L2.188|
                  |L2.184|
0000b8  2427              MOVS     r4,#0x27              ;153
0000ba  bf00              NOP                            ;154
                  |L2.188|
0000bc  bf00              NOP                            ;144
0000be  4620              MOV      r0,r4                 ;156
0000c0  e7ac              B        |L2.28|
;;;158    //动态分配内存
                          ENDP

0000c2  0000              DCW      0x0000
                  |L2.196|
                          DCD      picinfo
                  |L2.200|
                          DCD      lcddev
                  |L2.204|
                          DCD      pic_phy

                          AREA ||i.is_element_ok||, CODE, READONLY, ALIGN=2

                  is_element_ok PROC
;;;99     //返回值:0,不需要显示.1,需要显示
;;;100    u8 is_element_ok(u16 x,u16 y,u8 chg)
000000  4603              MOV      r3,r0
;;;101    {				  
;;;102    	if(x!=picinfo.staticx||y!=picinfo.staticy)
000002  4808              LDR      r0,|L3.36|
000004  6a00              LDR      r0,[r0,#0x20]  ; picinfo
000006  4298              CMP      r0,r3
000008  d103              BNE      |L3.18|
00000a  4806              LDR      r0,|L3.36|
00000c  6a40              LDR      r0,[r0,#0x24]  ; picinfo
00000e  4288              CMP      r0,r1
000010  d006              BEQ      |L3.32|
                  |L3.18|
;;;103    	{
;;;104    		if(chg==1)
000012  2a01              CMP      r2,#1
000014  d102              BNE      |L3.28|
;;;105    		{
;;;106    			picinfo.staticx=x;
000016  4803              LDR      r0,|L3.36|
000018  6203              STR      r3,[r0,#0x20]  ; picinfo
;;;107    			picinfo.staticy=y;
00001a  6241              STR      r1,[r0,#0x24]  ; picinfo
                  |L3.28|
;;;108    		} 
;;;109    		return 1;
00001c  2001              MOVS     r0,#1
                  |L3.30|
;;;110    	}else return 0;
;;;111    }
00001e  4770              BX       lr
                  |L3.32|
000020  2000              MOVS     r0,#0                 ;110
000022  e7fc              B        |L3.30|
;;;112    //智能画图
                          ENDP

                  |L3.36|
                          DCD      picinfo

                          AREA ||i.pic_memalloc||, CODE, READONLY, ALIGN=1

                  pic_memalloc PROC
;;;158    //动态分配内存
;;;159    void *pic_memalloc (u32 size)			
000000  b510              PUSH     {r4,lr}
;;;160    {
000002  4604              MOV      r4,r0
;;;161    	return (void*)mymalloc(SRAMIN,size);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       mymalloc
;;;162    }
00000c  bd10              POP      {r4,pc}
;;;163    //释放内存
                          ENDP


                          AREA ||i.pic_memfree||, CODE, READONLY, ALIGN=1

                  pic_memfree PROC
;;;163    //释放内存
;;;164    void pic_memfree (void* mf)		 
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166    	myfree(SRAMIN,mf);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       myfree
;;;167    }
00000c  bd10              POP      {r4,pc}
;;;168    
                          ENDP


                          AREA ||i.piclib_alpha_blend||, CODE, READONLY, ALIGN=2

                  piclib_alpha_blend PROC
;;;64     //返回值:混合后的颜色.
;;;65     u16 piclib_alpha_blend(u16 src,u16 dst,u8 alpha)
000000  b570              PUSH     {r4-r6,lr}
;;;66     {
000002  4603              MOV      r3,r0
;;;67     	u32 src2;
;;;68     	u32 dst2;	 
;;;69     	//Convert to 32bit |-----GGGGGG-----RRRRR------BBBBB|
;;;70     	src2=((src<<16)|src)&0x07E0F81F;
000004  ea434003          ORR      r0,r3,r3,LSL #16
000008  4e08              LDR      r6,|L6.44|
00000a  ea000406          AND      r4,r0,r6
;;;71     	dst2=((dst<<16)|dst)&0x07E0F81F;   
00000e  ea414001          ORR      r0,r1,r1,LSL #16
000012  ea000506          AND      r5,r0,r6
;;;72     	//Perform blending R:G:B with alpha in range 0..32
;;;73     	//Note that the reason that alpha may not exceed 32 is that there are only
;;;74     	//5bits of space between each R:G:B value, any higher value will overflow
;;;75     	//into the next component and deliver ugly result.
;;;76     	dst2=((((dst2-src2)*alpha)>>5)+src2)&0x07E0F81F;
000016  1b28              SUBS     r0,r5,r4
000018  4350              MULS     r0,r2,r0
00001a  eb041050          ADD      r0,r4,r0,LSR #5
00001e  ea000506          AND      r5,r0,r6
;;;77     	return (dst2>>16)|dst2;  
000022  ea454015          ORR      r0,r5,r5,LSR #16
000026  b280              UXTH     r0,r0
;;;78     }
000028  bd70              POP      {r4-r6,pc}
;;;79     //初始化智能画点
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x07e0f81f

                          AREA ||i.piclib_draw_hline||, CODE, READONLY, ALIGN=2

                  piclib_draw_hline PROC
;;;22     //lcd.h没有提供划横线函数,需要自己实现
;;;23     void piclib_draw_hline(u16 x0,u16 y0,u16 len,u16 color)
000000  b5f8              PUSH     {r3-r7,lr}
;;;24     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;25     	if((len==0)||(x0>lcddev.width)||(y0>lcddev.height))return;
00000a  b13e              CBZ      r6,|L7.28|
00000c  4809              LDR      r0,|L7.52|
00000e  8800              LDRH     r0,[r0,#0]  ; lcddev
000010  42a0              CMP      r0,r4
000012  db03              BLT      |L7.28|
000014  4807              LDR      r0,|L7.52|
000016  8840              LDRH     r0,[r0,#2]  ; lcddev
000018  42a8              CMP      r0,r5
00001a  da00              BGE      |L7.30|
                  |L7.28|
;;;26     	LCD_Fill(x0,y0,x0+len-1,y0,color);	
;;;27     }
00001c  bdf8              POP      {r3-r7,pc}
                  |L7.30|
00001e  19a0              ADDS     r0,r4,r6              ;26
000020  1e40              SUBS     r0,r0,#1              ;26
000022  b282              UXTH     r2,r0                 ;26
000024  462b              MOV      r3,r5                 ;26
000026  4629              MOV      r1,r5                 ;26
000028  4620              MOV      r0,r4                 ;26
00002a  9700              STR      r7,[sp,#0]            ;26
00002c  f7fffffe          BL       LCD_Fill
000030  bf00              NOP      
000032  e7f3              B        |L7.28|
;;;28     //填充颜色
                          ENDP

                  |L7.52|
                          DCD      lcddev

                          AREA ||i.piclib_fill_color||, CODE, READONLY, ALIGN=1

                  piclib_fill_color PROC
;;;31     //*color：颜色数组
;;;32     void piclib_fill_color(u16 x,u16 y,u16 width,u16 height,u16 *color)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;33     {  
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8020          LDR      r8,[sp,#0x20]
;;;34     	LCD_Color_Fill(x,y,x+width-1,y+height-1,color);	
000010  19e8              ADDS     r0,r5,r7
000012  1e40              SUBS     r0,r0,#1
000014  b283              UXTH     r3,r0
000016  19a0              ADDS     r0,r4,r6
000018  1e40              SUBS     r0,r0,#1
00001a  b282              UXTH     r2,r0
00001c  4629              MOV      r1,r5
00001e  4620              MOV      r0,r4
000020  f8cd8000          STR      r8,[sp,#0]
000024  f7fffffe          BL       LCD_Color_Fill
;;;35     }
000028  e8bd83f8          POP      {r3-r9,pc}
;;;36     //////////////////////////////////////////////////////////////////////////
                          ENDP


                          AREA ||i.piclib_init||, CODE, READONLY, ALIGN=2

                  piclib_init PROC
;;;38     //指定画点/读点
;;;39     void piclib_init(void)
000000  480e              LDR      r0,|L9.60|
;;;40     {
;;;41     	pic_phy.read_point=LCD_ReadPoint;  		//读点函数实现,仅BMP需要
000002  490f              LDR      r1,|L9.64|
000004  6008              STR      r0,[r1,#0]  ; pic_phy
;;;42     	pic_phy.draw_point=LCD_Fast_DrawPoint;	//画点函数实现
000006  480f              LDR      r0,|L9.68|
000008  6048              STR      r0,[r1,#4]  ; pic_phy
;;;43     	pic_phy.fill=LCD_Fill;					//填充函数实现,仅GIF需要
00000a  480f              LDR      r0,|L9.72|
00000c  6088              STR      r0,[r1,#8]  ; pic_phy
;;;44     	pic_phy.draw_hline=piclib_draw_hline;  	//画线函数实现,仅GIF需要
00000e  480f              LDR      r0,|L9.76|
000010  60c8              STR      r0,[r1,#0xc]  ; pic_phy
;;;45     	pic_phy.fillcolor=piclib_fill_color;  	//颜色填充函数实现,仅TJPGD需要 
000012  480f              LDR      r0,|L9.80|
000014  6108              STR      r0,[r1,#0x10]  ; pic_phy
;;;46     
;;;47     	picinfo.lcdwidth=lcddev.width;	//得到LCD的宽度像素
000016  480f              LDR      r0,|L9.84|
000018  8800              LDRH     r0,[r0,#0]  ; lcddev
00001a  490f              LDR      r1,|L9.88|
00001c  8008              STRH     r0,[r1,#0]
;;;48     	picinfo.lcdheight=lcddev.height;//得到LCD的高度像素
00001e  480d              LDR      r0,|L9.84|
000020  8840              LDRH     r0,[r0,#2]  ; lcddev
000022  8048              STRH     r0,[r1,#2]
;;;49     
;;;50     	picinfo.ImgWidth=0;	//初始化宽度为0
000024  2000              MOVS     r0,#0
000026  6048              STR      r0,[r1,#4]  ; picinfo
;;;51     	picinfo.ImgHeight=0;//初始化高度为0
000028  6088              STR      r0,[r1,#8]  ; picinfo
;;;52     	picinfo.Div_Fac=0;	//初始化缩放系数为0
00002a  60c8              STR      r0,[r1,#0xc]  ; picinfo
;;;53     	picinfo.S_Height=0;	//初始化设定的高度为0
00002c  6108              STR      r0,[r1,#0x10]  ; picinfo
;;;54     	picinfo.S_Width=0;	//初始化设定的宽度为0
00002e  6148              STR      r0,[r1,#0x14]  ; picinfo
;;;55     	picinfo.S_XOFF=0;	//初始化x轴的偏移量为0
000030  6188              STR      r0,[r1,#0x18]  ; picinfo
;;;56     	picinfo.S_YOFF=0;	//初始化y轴的偏移量为0
000032  61c8              STR      r0,[r1,#0x1c]  ; picinfo
;;;57     	picinfo.staticx=0;	//初始化当前显示到的x坐标为0
000034  6208              STR      r0,[r1,#0x20]  ; picinfo
;;;58     	picinfo.staticy=0;	//初始化当前显示到的y坐标为0
000036  6248              STR      r0,[r1,#0x24]  ; picinfo
;;;59     }
000038  4770              BX       lr
;;;60     //快速ALPHA BLENDING算法.
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      LCD_ReadPoint
                  |L9.64|
                          DCD      pic_phy
                  |L9.68|
                          DCD      LCD_Fast_DrawPoint
                  |L9.72|
                          DCD      LCD_Fill
                  |L9.76|
                          DCD      piclib_draw_hline
                  |L9.80|
                          DCD      piclib_fill_color
                  |L9.84|
                          DCD      lcddev
                  |L9.88|
                          DCD      picinfo

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  picinfo
                          %        40
                  pic_phy
                          %        20
