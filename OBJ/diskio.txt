; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\obj\diskio.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\diskio.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\ATK-ESP8266 -I..\CORE -I..\FATFS\src -I..\FATFS\exfuns -I..\HARDWARE\24CXX -I..\HARDWARE\IIC -I..\HARDWARE\KEY -I..\HARDWARE\LCD -I..\HARDWARE\LED -I..\HARDWARE\SDIO -I..\HARDWARE\SPI -I..\HARDWARE\TIMER -I..\HARDWARE\TOUCH -I..\HARDWARE\USART3 -I..\HARDWARE\W25QXX -I..\MALLOC -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\TEXT -I..\USER -I..\USMART -I..\PICTURE -I..\HARDWARE\OV7725 -I..\HARDWARE\EXTI -I..\HARDWARE\BEEP -I..\HARDWARE\DHT11 -I.\RTE\_Target_1 -ID:\Users\86132\AppData\Local\Arm\Packs\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=529 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\diskio.crf ..\FATFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;43     //初始化磁盘
;;;44     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;45     	BYTE pdrv				/* Physical drive nmuber to identify the drive */
;;;46     )
;;;47     {
000002  4604              MOV      r4,r0
;;;48     	u8 res=0;	    
000004  2500              MOVS     r5,#0
;;;49     	switch(pdrv)
000006  b91c              CBNZ     r4,|L1.16|
;;;50     	{
;;;51     		case SD_CARD://SD卡
;;;52     			res=SD_Init();//SD卡初始化 
000008  f7fffffe          BL       SD_Init
00000c  4605              MOV      r5,r0
;;;53       			break;
00000e  e001              B        |L1.20|
                  |L1.16|
;;;54     //		case EX_FLASH://外部flash
;;;55     //			W25QXX_Init();
;;;56     //			FLASH_SECTOR_COUNT=2048*12;//W25Q1218,前12M字节给FATFS占用 
;;;57     // 			break;
;;;58     		default:
;;;59     			res=1; 
000010  2501              MOVS     r5,#1
000012  bf00              NOP                            ;49
                  |L1.20|
000014  bf00              NOP                            ;53
;;;60     	}		 
;;;61     	if(res)return  STA_NOINIT;
000016  b10d              CBZ      r5,|L1.28|
000018  2001              MOVS     r0,#1
                  |L1.26|
;;;62     	else return 0; //初始化成功 
;;;63     } 
00001a  bd70              POP      {r4-r6,pc}
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;62
00001e  e7fc              B        |L1.26|
;;;64     //读扇区
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;152    #if _USE_IOCTL
;;;153    DRESULT disk_ioctl (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;154    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;155    	BYTE cmd,		/* Control code */
;;;156    	void *buff		/* Buffer to send/receive control data */
;;;157    )
;;;158    {
000004  4606              MOV      r6,r0
000006  4689              MOV      r9,r1
000008  4615              MOV      r5,r2
;;;159    DRESULT res;						  			     
;;;160    	if(pdrv==SD_CARD)//SD卡
00000a  bb46              CBNZ     r6,|L2.94|
;;;161    	{
;;;162    	    switch(cmd)
00000c  f1b90f00          CMP      r9,#0
000010  d009              BEQ      |L2.38|
000012  f1b90f01          CMP      r9,#1
000016  d013              BEQ      |L2.64|
000018  f1b90f02          CMP      r9,#2
00001c  d005              BEQ      |L2.42|
00001e  f1b90f03          CMP      r9,#3
000022  d119              BNE      |L2.88|
000024  e006              B        |L2.52|
                  |L2.38|
;;;163    	    {
;;;164    		    case CTRL_SYNC:
;;;165    				res = RES_OK; 
000026  2400              MOVS     r4,#0
;;;166    		        break;	 
000028  e018              B        |L2.92|
                  |L2.42|
;;;167    		    case GET_SECTOR_SIZE:
;;;168    				*(DWORD*)buff = 512; 
00002a  f44f7000          MOV      r0,#0x200
00002e  6028              STR      r0,[r5,#0]
;;;169    		        res = RES_OK;
000030  2400              MOVS     r4,#0
;;;170    		        break;	 
000032  e013              B        |L2.92|
                  |L2.52|
;;;171    		    case GET_BLOCK_SIZE:
;;;172    				*(WORD*)buff = SDCardInfo.CardBlockSize;
000034  481d              LDR      r0,|L2.172|
000036  f8b00050          LDRH     r0,[r0,#0x50]  ; SDCardInfo
00003a  8028              STRH     r0,[r5,#0]
;;;173    		        res = RES_OK;
00003c  2400              MOVS     r4,#0
;;;174    		        break;	 
00003e  e00d              B        |L2.92|
                  |L2.64|
;;;175    		    case GET_SECTOR_COUNT:
;;;176    		        *(DWORD*)buff = SDCardInfo.CardCapacity/512;
000040  481a              LDR      r0,|L2.172|
000042  f44f7200          MOV      r2,#0x200
000046  2300              MOVS     r3,#0
000048  e9d07112          LDRD     r7,r1,[r0,#0x48]
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       __aeabi_ldivmod
000052  6028              STR      r0,[r5,#0]
;;;177    		        res = RES_OK;
000054  2400              MOVS     r4,#0
;;;178    		        break;
000056  e001              B        |L2.92|
                  |L2.88|
;;;179    		    default:
;;;180    		        res = RES_PARERR;
000058  2404              MOVS     r4,#4
;;;181    		        break;
00005a  bf00              NOP      
                  |L2.92|
00005c  e022              B        |L2.164|
                  |L2.94|
;;;182    	    }
;;;183    	}else if(pdrv==EX_FLASH)	//外部FLASH  
00005e  2e01              CMP      r6,#1
000060  d11f              BNE      |L2.162|
;;;184    	{
;;;185    	    switch(cmd)
000062  f1b90f00          CMP      r9,#0
000066  d009              BEQ      |L2.124|
000068  f1b90f01          CMP      r9,#1
00006c  d011              BEQ      |L2.146|
00006e  f1b90f02          CMP      r9,#2
000072  d005              BEQ      |L2.128|
000074  f1b90f03          CMP      r9,#3
000078  d110              BNE      |L2.156|
00007a  e006              B        |L2.138|
                  |L2.124|
;;;186    	    {
;;;187    		    case CTRL_SYNC:
;;;188    				res = RES_OK; 
00007c  2400              MOVS     r4,#0
;;;189    		        break;	 
00007e  e00f              B        |L2.160|
                  |L2.128|
;;;190    		    case GET_SECTOR_SIZE:
;;;191    		        *(WORD*)buff = FLASH_SECTOR_SIZE;
000080  f44f7000          MOV      r0,#0x200
000084  8028              STRH     r0,[r5,#0]
;;;192    		        res = RES_OK;
000086  2400              MOVS     r4,#0
;;;193    		        break;	 
000088  e00a              B        |L2.160|
                  |L2.138|
;;;194    		    case GET_BLOCK_SIZE:
;;;195    		        *(WORD*)buff = FLASH_BLOCK_SIZE;
00008a  2008              MOVS     r0,#8
00008c  8028              STRH     r0,[r5,#0]
;;;196    		        res = RES_OK;
00008e  2400              MOVS     r4,#0
;;;197    		        break;	 
000090  e006              B        |L2.160|
                  |L2.146|
;;;198    		    case GET_SECTOR_COUNT:
;;;199    		        *(DWORD*)buff = FLASH_SECTOR_COUNT;
000092  4807              LDR      r0,|L2.176|
000094  8800              LDRH     r0,[r0,#0]  ; FLASH_SECTOR_COUNT
000096  6028              STR      r0,[r5,#0]
;;;200    		        res = RES_OK;
000098  2400              MOVS     r4,#0
;;;201    		        break;
00009a  e001              B        |L2.160|
                  |L2.156|
;;;202    		    default:
;;;203    		        res = RES_PARERR;
00009c  2404              MOVS     r4,#4
;;;204    		        break;
00009e  bf00              NOP      
                  |L2.160|
0000a0  e000              B        |L2.164|
                  |L2.162|
;;;205    	    }
;;;206    	}else res=RES_ERROR;//其他的不支持
0000a2  2401              MOVS     r4,#1
                  |L2.164|
;;;207        return res;
0000a4  4620              MOV      r0,r4
;;;208    }
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;209    #endif
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      SDCardInfo
                  |L2.176|
                          DCD      FLASH_SECTOR_COUNT

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;68     //count:需要读取的扇区数
;;;69     DRESULT disk_read (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;70     	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;71     	BYTE *buff,		/* Data buffer to store read data */
;;;72     	DWORD sector,	/* Sector address in LBA */
;;;73     	UINT count		/* Number of sectors to read */
;;;74     )
;;;75     {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;76     	u8 res=0; 
00000c  f04f0800          MOV      r8,#0
;;;77         if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L3.24|
000012  2004              MOVS     r0,#4
                  |L3.20|
;;;78     	switch(pdrv)
;;;79     	{
;;;80     		case SD_CARD://SD卡
;;;81     			res=SD_ReadDisk(buff,sector,count);	 
;;;82     			while(res)//读出错
;;;83     			{
;;;84     				SD_Init();	//重新初始化SD卡
;;;85     				res=SD_ReadDisk(buff,sector,count);	
;;;86     				//printf("sd rd error:%d\r\n",res);
;;;87     			}
;;;88     			break;
;;;89     //		case EX_FLASH://外部flash
;;;90     //			for(;count>0;count--)
;;;91     //			{
;;;92     //				W25QXX_Read(buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;93     //				sector++;
;;;94     //				buff+=FLASH_SECTOR_SIZE;
;;;95     //			}
;;;96     //			res=0;
;;;97     //			break;
;;;98     		default:
;;;99     			res=1; 
;;;100    	}
;;;101       //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;102        if(res==0x00)return RES_OK;	 
;;;103        else return RES_ERROR;	   
;;;104    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  b995              CBNZ     r5,|L3.64|
00001a  b2e2              UXTB     r2,r4                 ;81
00001c  4639              MOV      r1,r7                 ;81
00001e  4630              MOV      r0,r6                 ;81
000020  f7fffffe          BL       SD_ReadDisk
000024  4680              MOV      r8,r0                 ;81
000026  e007              B        |L3.56|
                  |L3.40|
000028  f7fffffe          BL       SD_Init
00002c  b2e2              UXTB     r2,r4                 ;85
00002e  4639              MOV      r1,r7                 ;85
000030  4630              MOV      r0,r6                 ;85
000032  f7fffffe          BL       SD_ReadDisk
000036  4680              MOV      r8,r0                 ;85
                  |L3.56|
000038  f1b80f00          CMP      r8,#0                 ;82
00003c  d1f4              BNE      |L3.40|
00003e  e002              B        |L3.70|
                  |L3.64|
000040  f04f0801          MOV      r8,#1                 ;99
000044  bf00              NOP                            ;78
                  |L3.70|
000046  bf00              NOP                            ;88
000048  f1b80f00          CMP      r8,#0                 ;102
00004c  d101              BNE      |L3.82|
00004e  2000              MOVS     r0,#0                 ;102
000050  e7e0              B        |L3.20|
                  |L3.82|
000052  2001              MOVS     r0,#1                 ;103
000054  e7de              B        |L3.20|
;;;105    //写扇区
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;36     //获得磁盘状态
;;;37     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;38     	BYTE pdrv		/* Physical drive nmuber to identify the drive */
;;;39     )
;;;40     { 
;;;41     	return RES_OK;
000002  2000              MOVS     r0,#0
;;;42     }  
000004  4770              BX       lr
;;;43     //初始化磁盘
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;110    #if _USE_WRITE
;;;111    DRESULT disk_write (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;112    	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
;;;113    	const BYTE *buff,	/* Data to be written */
;;;114    	DWORD sector,		/* Sector address in LBA */
;;;115    	UINT count			/* Number of sectors to write */
;;;116    )
;;;117    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;118    	u8 res=0;  
00000c  f04f0800          MOV      r8,#0
;;;119        if (!count)return RES_PARERR;//count不能等于0，否则返回参数错误		 	 
000010  b914              CBNZ     r4,|L5.24|
000012  2004              MOVS     r0,#4
                  |L5.20|
;;;120    	switch(pdrv)
;;;121    	{
;;;122    		case SD_CARD://SD卡
;;;123    			res=SD_WriteDisk((u8*)buff,sector,count);
;;;124    			while(res)//写出错
;;;125    			{
;;;126    				SD_Init();	//重新初始化SD卡
;;;127    				res=SD_WriteDisk((u8*)buff,sector,count);	
;;;128    				//printf("sd wr error:%d\r\n",res);
;;;129    			}
;;;130    			break;
;;;131    //		case EX_FLASH://外部flash
;;;132    //			for(;count>0;count--)
;;;133    //			{										    
;;;134    //				W25QXX_Write((u8*)buff,sector*FLASH_SECTOR_SIZE,FLASH_SECTOR_SIZE);
;;;135    //				sector++;
;;;136    //				buff+=FLASH_SECTOR_SIZE;
;;;137    //			}
;;;138    //			res=0;
;;;139    //			break;
;;;140    		default:
;;;141    			res=1; 
;;;142    	}
;;;143        //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;144        if(res == 0x00)return RES_OK;	 
;;;145        else return RES_ERROR;	
;;;146    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L5.24|
000018  b995              CBNZ     r5,|L5.64|
00001a  b2e2              UXTB     r2,r4                 ;123
00001c  4639              MOV      r1,r7                 ;123
00001e  4630              MOV      r0,r6                 ;123
000020  f7fffffe          BL       SD_WriteDisk
000024  4680              MOV      r8,r0                 ;123
000026  e007              B        |L5.56|
                  |L5.40|
000028  f7fffffe          BL       SD_Init
00002c  b2e2              UXTB     r2,r4                 ;127
00002e  4639              MOV      r1,r7                 ;127
000030  4630              MOV      r0,r6                 ;127
000032  f7fffffe          BL       SD_WriteDisk
000036  4680              MOV      r8,r0                 ;127
                  |L5.56|
000038  f1b80f00          CMP      r8,#0                 ;124
00003c  d1f4              BNE      |L5.40|
00003e  e002              B        |L5.70|
                  |L5.64|
000040  f04f0801          MOV      r8,#1                 ;141
000044  bf00              NOP                            ;120
                  |L5.70|
000046  bf00              NOP                            ;130
000048  f1b80f00          CMP      r8,#0                 ;144
00004c  d101              BNE      |L5.82|
00004e  2000              MOVS     r0,#0                 ;144
000050  e7e0              B        |L5.20|
                  |L5.82|
000052  2001              MOVS     r0,#1                 ;145
000054  e7de              B        |L5.20|
;;;147    #endif
                          ENDP


                          AREA ||i.ff_memalloc||, CODE, READONLY, ALIGN=1

                  ff_memalloc PROC
;;;218    //动态分配内存
;;;219    void *ff_memalloc (UINT size)			
000000  b510              PUSH     {r4,lr}
;;;220    {
000002  4604              MOV      r4,r0
;;;221    	return (void*)mymalloc(SRAMIN,size);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       mymalloc
;;;222    }
00000c  bd10              POP      {r4,pc}
;;;223    //释放内存
                          ENDP


                          AREA ||i.ff_memfree||, CODE, READONLY, ALIGN=1

                  ff_memfree PROC
;;;223    //释放内存
;;;224    void ff_memfree (void* mf)		 
000000  b510              PUSH     {r4,lr}
;;;225    {
000002  4604              MOV      r4,r0
;;;226    	myfree(SRAMIN,mf);
000004  4621              MOV      r1,r4
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       myfree
;;;227    }
00000c  bd10              POP      {r4,pc}
;;;228    
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;213    //15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */                                                                                                                                                                                                                                                
;;;214    DWORD get_fattime (void)
000000  2000              MOVS     r0,#0
;;;215    {				 
;;;216    	return 0;
;;;217    }			 
000002  4770              BX       lr
;;;218    //动态分配内存
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  FLASH_SECTOR_COUNT
000000  6000              DCW      0x6000
